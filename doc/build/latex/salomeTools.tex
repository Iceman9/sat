% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{salomeTools Documentation}
\date{April 24, 2018}
\release{5.0.0dev}
\author{CEA DEN/DANS/DM2S/STMF/LGLS}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


{\hfill\scalebox{1.000000}{\includegraphics{sat_about.png}}\hfill}

\begin{notice}{warning}{Warning:}
This documentation is under construction.
\end{notice}

The \textbf{Sa}lome\textbf{T}ools (sat) is a suite of commands
that can be used to perform operations on \href{http://www.salome-platform.org}{SALOME} (http://www.salome-platform.org).

For example, sat allows you to compile SALOME's codes
(prerequisites, products)
create application, run tests, create package, etc.

This utility code is a set of \href{https://docs.python.org/2.7}{Python} (https://docs.python.org/2.7) scripts files.


\chapter{Quick start}
\label{index:svn}\label{index:quick-start}\label{index:salome-tools}

\section{Installation}
\label{installation_of_sat:installation}\label{installation_of_sat::doc}
Usually user could find (and use) command \textbf{sat} directly after a `detar' installation of SALOME.

\begin{Verbatim}[commandchars=\\\{\}]
tar -xf .../SALOME\PYGZus{}xx.tgz
\PYG{n+nb}{cd }SALOME\PYGZus{}xx
ls -l sat      \PYG{c}{\PYGZsh{} sat -\textgreater{} salomeTools/sat}
\end{Verbatim}

Python package (scripts of salomeTools) actually remains in directory \emph{salomeTools}.


\section{Configuration}
\label{configuration:configuration}\label{configuration::doc}
\emph{salomeTools} uses files to store its configuration parameters.

There are several configuration files which are loaded by salomeTools in a specific order.
When all the files are loaded a \emph{config} object is created.
Then, this object is passed to all command scripts.


\subsection{Syntax}
\label{configuration:syntax}
The configuration files use a python-like structure format
(see \href{http://www.red-dove.com/config-doc/}{config module} (http://www.red-dove.com/config-doc/) for a complete description).
\begin{itemize}
\item {} 
\textbf{\{\}} define a dictionary,

\item {} 
\textbf{{[}{]}} define a list,

\item {} 
\textbf{@} can be used to include a file,

\item {} 
\textbf{\$prefix} reference to another parameter (ex: \code{\$PRODUCT.name}),

\item {} 
\textbf{\#} comments.

\end{itemize}

\begin{notice}{note}{Note:}
in this documentation a reference to a configuration parameter will be noted \code{XXX.YYY}.
\end{notice}


\subsection{Description}
\label{configuration:description}

\subsubsection{VARS section}
\label{configuration:vars-section}\label{configuration:id1}
\begin{DUlineblock}{0em}
\item[] This section is dynamically created by salomeTools at run time.
\item[] It contains information about the environment: date, time, OS, architecture etc.
\end{DUlineblock}

\begin{Verbatim}[commandchars=\\\{\}]
\# to get the current setting
sat config --value VARS
\end{Verbatim}


\subsubsection{PRODUCTS section}
\label{configuration:products-section}
\begin{DUlineblock}{0em}
\item[] This section is defined in the product file.
\item[] It contains instructions on how to build a version of SALOME (list of prerequisites-products and versions)
\end{DUlineblock}

\begin{Verbatim}[commandchars=\\\{\}]
\# to get the current setting
sat config SALOME-xx --value PRODUCTS
\end{Verbatim}


\subsubsection{APPLICATION section}
\label{configuration:application-section}
\begin{DUlineblock}{0em}
\item[] This section is optional, it is also defined in the product file.
\item[] It gives additional parameters to create an application based on SALOME, as versions of products to use.
\end{DUlineblock}

\begin{Verbatim}[commandchars=\\\{\}]
\# to get the current setting
sat config SALOME-xx --value APPLICATION
\end{Verbatim}


\subsubsection{USER section}
\label{configuration:user-section}\label{configuration:id2}
This section is defined by the user configuration file,
\code{\textasciitilde{}/.salomeTools/salomeTools.pyconf}.

The \code{USER} section defines some parameters (not exhaustive):
\begin{itemize}
\item {} 
\textbf{workDir} :
\begin{quote}

\begin{DUlineblock}{0em}
\item[] The working directory.
\item[] Each product will be usually installed here (in sub-directories).
\end{DUlineblock}
\end{quote}

\item {} 
\textbf{browser} : The web browser to use (\emph{firefox}).

\item {} 
\textbf{editor} : The editor to use (\emph{vi, pluma}).

\item {} 
and other user preferences.

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\# to get the current setting
sat config SALOME-xx --value USER
\end{Verbatim}


\section{Usage of SAlomeTools}
\label{usage_of_sat:svn}\label{usage_of_sat:usage-of-salometools}\label{usage_of_sat::doc}

\subsection{Usage}
\label{usage_of_sat:usage}
sat usage is a Command Line Interface (\href{https://en.wikipedia.org/wiki/Command-line\_interface}{CLI} (https://en.wikipedia.org/wiki/Command-line\_interface)).

\begin{Verbatim}[commandchars=\\\{\}]
sat \PYG{o}{[}generic\PYGZus{}options\PYG{o}{]} \PYG{o}{[}\PYG{n+nb}{command}\PYG{o}{]} \PYG{o}{[}product\PYG{o}{]} \PYG{o}{[}command\PYGZus{}options\PYG{o}{]}
\end{Verbatim}


\subsubsection{Options of sat}
\label{usage_of_sat:options-of-sat}
Useful \emph{not exhaustive} generic options of \emph{sat} CLI.


\paragraph{\emph{--help or -h}}
\label{usage_of_sat:help-or-h}
Get help as simple text.

\begin{Verbatim}[commandchars=\\\{\}]
sat --help          \PYG{c}{\PYGZsh{} get the list of existing commands}
sat --help compile  \PYG{c}{\PYGZsh{} get the help on a specific command 'compile'}
\end{Verbatim}


\paragraph{\emph{--debug or -g}}
\label{usage_of_sat:debug-or-g}
Execution in debug mode allows to see more trace and \emph{stack} if an exception is raised.


\paragraph{\emph{--verbose or -v}}
\label{usage_of_sat:verbose-or-v}
Change verbosity level (default is 3).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} for product 'SALOME\PYGZus{}xx' for example}
\PYG{c}{\PYGZsh{} execute compile command in debug mode with trace level 4}
sat -g -v 4 compile SALOME\PYGZus{}xx
\end{Verbatim}


\subsection{Build a SALOME product}
\label{usage_of_sat:build-a-salome-product}

\subsubsection{Get the list of available products}
\label{usage_of_sat:get-the-list-of-available-products}
To get the list of the current available products in your context:

\begin{Verbatim}[commandchars=\\\{\}]
sat config --list
\end{Verbatim}


\subsubsection{Prepare sources of a product}
\label{usage_of_sat:prepare-sources-of-a-product}
To prepare (get) \emph{all} the sources of a product (\emph{SALOME\_xx} for example):

\begin{Verbatim}[commandchars=\\\{\}]
sat prepare SALOME\PYGZus{}xx
\end{Verbatim}

\begin{DUlineblock}{0em}
\item[] The sources are usually copied in directories
\item[] \emph{\$USER.workDir + SALOME\_xx... + SOURCES + \$PRODUCT.name}
\end{DUlineblock}


\subsubsection{Compile SALOME}
\label{usage_of_sat:compile-salome}
To compile products:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} compile all prerequisites/products}
sat compile SALOME\PYGZus{}xx

\PYG{c}{\PYGZsh{} compile only 2 products (KERNEL and SAMPLES), if not done yet}
sat compile SALOME\PYGZus{}xx --products KERNEL,SAMPLES

\PYG{c}{\PYGZsh{} compile only 2 products, unconditionaly}
sat compile SALOME\PYGZus{}xx ---products SAMPLES --clean\PYGZus{}all
\end{Verbatim}

\begin{DUlineblock}{0em}
\item[] The products are usually build in the directories
\item[] \emph{\$USER.workDir + SALOME\_xx... + BUILD + \$PRODUCT.name}
\item[] 
\item[] The products are usually installed in the directories
\item[] \emph{\$USER.workDir + SALOME\_xx... + INSTALL + \$PRODUCT.name}
\end{DUlineblock}


\chapter{List of Commands}
\label{index:list-of-commands}

\section{Command config}
\label{commands/config:svn}\label{commands/config:command-config}\label{commands/config::doc}

\subsection{Description}
\label{commands/config:description}
The \textbf{config} command manages sat configuration.
It allows display, manipulation and operation on configuration files


\subsection{Usage}
\label{commands/config:usage}\begin{itemize}
\item {} 
Edit the user personal configuration file \code{\$HOME/.salomeTools/SAT.pyconf}. It is used to store the user personal choices, like the favorite editor, browser, pdf viewer:

\begin{Verbatim}[commandchars=\\\{\}]
sat config --edit
\end{Verbatim}

\item {} 
List the available applications (they come from the sat projects defined in \code{data/local.pyconf}:

\begin{Verbatim}[commandchars=\\\{\}]
sat config --list
\end{Verbatim}

\item {} 
Edit the configuration of an application:

\begin{Verbatim}[commandchars=\\\{\}]
sat config \textless{}application\textgreater{} --edit
\end{Verbatim}

\item {} 
Copy an application configuration file into the user personal directory:

\begin{Verbatim}[commandchars=\\\{\}]
sat config \textless{}application\textgreater{} --copy [new\_name]
\end{Verbatim}

\item {} 
\begin{DUlineblock}{0em}
\item[] Print the value of a configuration parameter.
\item[] Use the automatic completion to get recursively the parameter names.
\item[] Use \emph{--no\_label} option to get \emph{only} the value, \emph{without} label (useful in automatic scripts).
\item[] Examples (with \emph{SALOME-xx} as \emph{SALOME-8.4.0} ):
\end{DUlineblock}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} sat config --value \textless{}parameter\PYGZus{}path\textgreater{}}
sat config --value .         \PYG{c}{\PYGZsh{} all the configuration}
sat config --value LOCAL
sat config --value LOCAL.workdir

\PYG{c}{\PYGZsh{} sat config \textless{}application\textgreater{} --value \textless{}parameter\PYGZus{}path\textgreater{}}
sat config SALOME-xx --value APPLICATION.workdir
sat config SALOME-xx --no\PYGZus{}label --value APPLICATION.workdir
\end{Verbatim}

\item {} 
\begin{DUlineblock}{0em}
\item[] Print in one-line-by-value mode the value of a configuration parameter,
\item[] with its source \emph{expression}, if any.
\item[] This is a debug mode, useful for developers.
\item[] Prints the parameter path, the source expression if any, and the final value:
\end{DUlineblock}

\begin{Verbatim}[commandchars=\\\{\}]
sat config SALOME-xx -g USER
\end{Verbatim}

\begin{notice}{note}{Note:}
And so, \emph{not only for fun}, to get \textbf{all expressions} of configuration

\begin{Verbatim}[commandchars=\\\{\}]
sat config SALOME-xx -g . \textbar{} grep -e \PYG{l+s+s2}{"--\textgreater{}"}
\end{Verbatim}
\end{notice}

\item {} 
Print the patches that are applied:

\begin{Verbatim}[commandchars=\\\{\}]
sat config SALOME-xx --show\_patchs
\end{Verbatim}

\item {} 
Get information on a product configuration:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} sat config \textless{}application\textgreater{} --info \textless{}product\textgreater{}}
sat config SALOME-xx --info KERNEL
sat config SALOME-xx --info qt
\end{Verbatim}

\end{itemize}


\subsection{Some useful configuration pathes}
\label{commands/config:some-useful-configuration-pathes}
Exploring a current configuration.
\begin{itemize}
\item {} 
\textbf{PATHS}: To get list of directories where to find files.

\item {} 
\textbf{USER}: To get user preferences (editor, pdf viewer, web browser, default working dir).

\end{itemize}

sat commands:

\begin{Verbatim}[commandchars=\\\{\}]
sat config SALOME-xx -v PATHS
sat config SALOME-xx -v USERS
\end{Verbatim}


\section{Command prepare}
\label{commands/prepare:svn}\label{commands/prepare:command-prepare}\label{commands/prepare::doc}

\subsection{Description}
\label{commands/prepare:description}
The \textbf{prepare} command brings the sources of an application in the \emph{sources
application directory}, in order to compile them with the compile command.

The sources can be prepared from VCS software (\emph{cvs, svn, git}), an archive or a directory.

\begin{notice}{warning}{Warning:}
When sat prepares a product, it first removes the
existing directory, except if the development mode is activated.
When you are working on a product, you need to declare in
the application configuration this product in \textbf{dev} mode.
\end{notice}


\subsection{Remarks}
\label{commands/prepare:remarks}

\subsubsection{VCS bases (git, svn, cvs)}
\label{commands/prepare:vcs-bases-git-svn-cvs}
The \emph{prepare} command does not manage authentication on the cvs server.
For example, to prepare modules from a cvs server, you first need to login once.

To avoid typing a password for each product,
you may use a ssh key with passphrase, or store your password
(in .cvspass or .gitconfig files).
If you have security concerns, it is also possible to use
a bash agent and type your password only once.


\subsubsection{Dev mode}
\label{commands/prepare:dev-mode}
By default \emph{prepare} uses \emph{export} mode: it creates an image
of the sources, corresponding to the tag or branch specified,
without any link to the VCS base.
To perform a \emph{checkout} (svn, cvs) or a \emph{git clone} (git),
you need to declare the product in dev mode in your application configuration:
edit the application configuration file (pyconf) and modify the product declaration:

\begin{Verbatim}[commandchars=\\\{\}]
sat config \textless{}application\textgreater{} -e
\PYG{c}{\PYGZsh{} and edit the product section:}
\PYG{c}{\PYGZsh{}   \textless{}product\textgreater{} : \PYGZob{}tag : "my\PYGZus{}tag", dev : "yes", debug : "yes"\PYGZcb{}}
\end{Verbatim}

The first time you will execute the \emph{sat prepare} command,
your module will be downloaded in \emph{checkout} mode
(inside the SOURCES directory of the application.
Then, you can develop in this repository, and finally push
them in the base when they are ready.
If you type during the development process by mistake
a \emph{sat prepare} command, the sources in dev mode will
not be altered/removed (Unless you use -f option)


\subsection{Usage}
\label{commands/prepare:usage}\begin{itemize}
\item {} 
Prepare the sources of a complete application in SOURCES directory (all products):

\begin{Verbatim}[commandchars=\\\{\}]
sat prepare \textless{}application\textgreater{}
\end{Verbatim}

\item {} 
Prepare only some modules:

\begin{Verbatim}[commandchars=\\\{\}]
sat prepare \textless{}application\textgreater{}  --products \textless{}product1\textgreater{},\textless{}product2\textgreater{} ...
\end{Verbatim}

\item {} 
Use --force to force to prepare the products in development mode
(this will remove the sources and do a new clone/checkout):

\begin{Verbatim}[commandchars=\\\{\}]
sat prepare \textless{}application\textgreater{} --force
\end{Verbatim}

\item {} 
Use --force\_patch to force to apply patch to the products
in development mode (otherwise they are not applied):

\begin{Verbatim}[commandchars=\\\{\}]
sat prepare \textless{}application\textgreater{} --force\_patch
\end{Verbatim}

\end{itemize}


\subsection{Some useful configuration pathes}
\label{commands/prepare:some-useful-configuration-pathes}
Command \emph{sat prepare} uses the \emph{pyconf file configuration} of each product to know how to get the sources.

\begin{notice}{note}{Note:}
to verify configuration of a product, and get name of this \emph{pyconf files configuration}

\begin{Verbatim}[commandchars=\\\{\}]
sat config \textless{}application\textgreater{} --info \textless{}product\textgreater{}
\end{Verbatim}
\end{notice}
\begin{itemize}
\item {} 
\textbf{get\_method}: the method to use to prepare the module, possible values are cvs, git, archive, dir.

\item {} 
\textbf{git\_info} : (used if get\_method = git) information to prepare sources from git.

\item {} 
\textbf{svn\_info} : (used if get\_method = svn) information to prepare sources from cvs.

\item {} 
\textbf{cvs\_info} : (used if get\_method = cvs) information to prepare sources from cvs.

\item {} 
\textbf{archive\_info} : (used if get\_method = archive) the path to the archive.

\item {} 
\textbf{dir\_info} : (used if get\_method = dir) the directory with the sources.

\end{itemize}


\section{Command compile}
\label{commands/compile:svn}\label{commands/compile:command-compile}\label{commands/compile::doc}

\subsection{Description}
\label{commands/compile:description}
The \textbf{compile} command allows compiling the products of a \href{http://www.salome-platform.org}{SALOME} (http://www.salome-platform.org) application.


\subsection{Usage}
\label{commands/compile:usage}\begin{itemize}
\item {} 
Compile a complete application:

\begin{Verbatim}[commandchars=\\\{\}]
sat compile \textless{}application\textgreater{}
\end{Verbatim}

\item {} 
Compile only some products:

\begin{Verbatim}[commandchars=\\\{\}]
sat compile \textless{}application\textgreater{} --products \textless{}product1\textgreater{},\textless{}product2\textgreater{} ...
\end{Verbatim}

\item {} 
Use \emph{sat -t} to duplicate the logs in the terminal (by default the log are stored and displayed with \emph{sat log} command):

\begin{Verbatim}[commandchars=\\\{\}]
sat -t compile \textless{}application\textgreater{} --products \textless{}product1\textgreater{}
\end{Verbatim}

\item {} 
Compile a module and its dependencies:

\begin{Verbatim}[commandchars=\\\{\}]
sat compile \textless{}application\textgreater{} --products med --with\_fathers
\end{Verbatim}

\item {} 
Compile a module and the modules depending on it (for example plugins):

\begin{Verbatim}[commandchars=\\\{\}]
sat compile \textless{}application\textgreater{} --products med --with\_children
\end{Verbatim}

\item {} 
Clean the build and install directories before starting compilation:

\begin{Verbatim}[commandchars=\\\{\}]
sat compile \textless{}application\textgreater{} --products GEOM  --clean\_all
\end{Verbatim}

\begin{notice}{note}{Note:}
\begin{DUlineblock}{0em}
\item[] a warning will be shown if option \emph{--products} is missing
\item[] (as it will clean everything)
\end{DUlineblock}
\end{notice}

\item {} 
Clean only the install directories before starting compilation:

\begin{Verbatim}[commandchars=\\\{\}]
sat compile \textless{}application\textgreater{} --clean\_install
\end{Verbatim}

\item {} 
Add options for make:

\begin{Verbatim}[commandchars=\\\{\}]
sat compile \textless{}application\textgreater{} --products \textless{}product\textgreater{} --make\_flags \textless{}flags\textgreater{}
\end{Verbatim}

\item {} 
Use the \emph{--check} option to execute the unit tests after compilation:

\begin{Verbatim}[commandchars=\\\{\}]
sat compile \textless{}application\textgreater{} --check
\end{Verbatim}

\item {} 
Remove the build directory after successful compilation (some build directory like qt are big):

\begin{Verbatim}[commandchars=\\\{\}]
sat compile \textless{}application\textgreater{} --products qt --clean\_build\_after
\end{Verbatim}

\item {} 
Stop the compilation as soon as the compilation of a module fails:

\begin{Verbatim}[commandchars=\\\{\}]
sat compile \textless{}product\textgreater{} --stop\_first\_fail
\end{Verbatim}

\item {} 
Do not compile, just show if products are installed or not, and where is the installation:

\begin{Verbatim}[commandchars=\\\{\}]
sat compile \textless{}application\textgreater{} --show
\end{Verbatim}

\end{itemize}


\subsection{Some useful configuration pathes}
\label{commands/compile:some-useful-configuration-pathes}
The way to compile a product is defined in the \emph{pyconf file configuration}.
The main options are:
\begin{itemize}
\item {} 
\textbf{build\_source} : the method used to build the product (cmake/autotools/script)

\item {} 
\textbf{compil\_script} : the compilation script if build\_source is equal to ``script''

\item {} 
\textbf{cmake\_options} : additional options for cmake.

\item {} 
\textbf{nb\_proc} : number of jobs to use with make for this product.

\end{itemize}


\section{Command launcher}
\label{commands/launcher:svn}\label{commands/launcher:command-launcher}\label{commands/launcher::doc}

\subsection{Description}
\label{commands/launcher:description}
The \textbf{launcher} command creates a SALOME launcher, a python script file to start \href{http://www.salome-platform.org}{SALOME} (http://www.salome-platform.org).


\subsection{Usage}
\label{commands/launcher:usage}\begin{itemize}
\item {} 
Create a launcher:

\begin{Verbatim}[commandchars=\\\{\}]
sat launcher \textless{}application\textgreater{}
\end{Verbatim}

Generate a launcher in the application directory, i.e \code{\$APPLICATION.workdir}.

\item {} 
Create a launcher with a given name (default name is \code{APPLICATION.profile.launcher\_name})

\begin{Verbatim}[commandchars=\\\{\}]
sat launcher \textless{}application\textgreater{} --name ZeLauncher
\end{Verbatim}

The launcher will be called \emph{ZeLauncher}.

\item {} 
Set a specific resources catalog:

\begin{Verbatim}[commandchars=\\\{\}]
sat launcher \textless{}application\textgreater{}  --catalog  \textless{}path of a salome resources catalog\textgreater{}
\end{Verbatim}

Note that the catalog specified will be copied to the profile directory.

\item {} 
Generate the catalog for a list of machines:

\begin{Verbatim}[commandchars=\\\{\}]
sat launcher \textless{}application\textgreater{} --gencat \textless{}list of machines\textgreater{}
\end{Verbatim}

This will create a catalog by querying each machine (memory, number of processor) with ssh.

\item {} 
Generate a mesa launcher (if mesa and llvm are parts of the application). Use this option only if you have to use salome through ssh and have problems with ssh X forwarding of OpengGL modules (like Paravis):

\begin{Verbatim}[commandchars=\\\{\}]
sat launcher \textless{}application\textgreater{} --use\_mesa
\end{Verbatim}

\end{itemize}


\subsection{Configuration}
\label{commands/launcher:configuration}
Some useful configuration pathes:
\begin{itemize}
\item {} 
\textbf{APPLICATION.profile}
\begin{itemize}
\item {} 
\textbf{product} : the name of the profile product (the product in charge of holding the application stuff, like logos, splashscreen)

\item {} 
\textbf{launcher\_name} : the name of the launcher.

\end{itemize}

\end{itemize}


\section{Command application}
\label{commands/application:svn}\label{commands/application::doc}\label{commands/application:command-application}

\subsection{Description}
\label{commands/application:description}
The \textbf{application} command creates a virtual \href{http://www.salome-platform.org}{SALOME} (http://www.salome-platform.org) application.
Virtual SALOME applications are used to start SALOME when distribution is needed.


\subsection{Usage}
\label{commands/application:usage}\begin{itemize}
\item {} 
Create an application:

\begin{Verbatim}[commandchars=\\\{\}]
sat application \textless{}application\textgreater{}
\end{Verbatim}

Create the virtual application directory in the salomeTool application directory \code{\$APPLICATION.workdir}.

\item {} 
Give a name to the application:

\begin{Verbatim}[commandchars=\\\{\}]
sat application \textless{}application\textgreater{} --name \textless{}my\_application\_name\textgreater{}
\end{Verbatim}

\emph{Remark}: this option overrides the name given in the virtual\_app section of the configuration file \code{\$APPLICATION.virtual\_app.name}.

\item {} 
Change the directory where the application is created:

\begin{Verbatim}[commandchars=\\\{\}]
sat application \textless{}application\textgreater{} --target \textless{}my\_application\_directory\textgreater{}
\end{Verbatim}

\item {} 
Set a specific \href{http://www.salome-platform.org}{SALOME} (http://www.salome-platform.org) resources catalog (it will be used for the distribution of components on distant machines):

\begin{Verbatim}[commandchars=\\\{\}]
sat application \textless{}application\textgreater{} --catalog \textless{}path\_to\_catalog\textgreater{}
\end{Verbatim}

Note that the catalog specified will be copied to the application directory.

\item {} 
Generate the catalog for a list of machines:

\begin{Verbatim}[commandchars=\\\{\}]
sat application \textless{}application\textgreater{} --gencat machine1,machine2,machine3
\end{Verbatim}

This will create a catalog by querying each machine through ssh protocol (memory, number of processor) with ssh.

\item {} 
Generate a mesa application (if mesa and llvm are parts of the application). Use this option only if you have to use salome through ssh and have problems with ssh X forwarding of OpengGL modules (like Paravis):

\begin{Verbatim}[commandchars=\\\{\}]
sat launcher \textless{}application\textgreater{} --use\_mesa
\end{Verbatim}

\end{itemize}


\subsection{Some useful configuration pathes}
\label{commands/application:some-useful-configuration-pathes}
The virtual application can be configured with the virtual\_app section of the configutation file.
\begin{itemize}
\item {} 
\textbf{APPLICATION.virtual\_app}
\begin{itemize}
\item {} 
\textbf{name} : name of the launcher (to replace the default runAppli).

\item {} 
\textbf{application\_name} : (optional) the name of the virtual application directory, if missing the default value is \code{\$name + \_appli}.

\end{itemize}

\end{itemize}


\section{Command log}
\label{commands/log:svn}\label{commands/log:command-log}\label{commands/log::doc}

\subsection{Description}
\label{commands/log:description}
The \textbf{log} command displays sat log in a web browser or in a terminal.


\subsection{Usage}
\label{commands/log:usage}\begin{itemize}
\item {} 
Show (in a web browser) the log of the commands corresponding to an application:

\begin{Verbatim}[commandchars=\\\{\}]
sat log \textless{}application\textgreater{}
\end{Verbatim}

\item {} 
Show the log for commands that do not use any application:

\begin{Verbatim}[commandchars=\\\{\}]
sat log
\end{Verbatim}

\item {} 
The --terminal (or -t) display the log directly in the terminal, through a \href{https://en.wikipedia.org/wiki/Command-line\_interface}{CLI} (https://en.wikipedia.org/wiki/Command-line\_interface) interactive menu:

\begin{Verbatim}[commandchars=\\\{\}]
sat log \textless{}application\textgreater{} --terminal
\end{Verbatim}

\item {} 
The --last option displays only the last command:

\begin{Verbatim}[commandchars=\\\{\}]
sat log \textless{}application\textgreater{} --last
\end{Verbatim}

\item {} 
To access the last compilation log in terminal mode, use --last\_terminal option:

\begin{Verbatim}[commandchars=\\\{\}]
sat log \textless{}application\textgreater{} --last\_terminal
\end{Verbatim}

\item {} 
The --clean (int) option erases the n older log files and print the number of remaining log files:

\begin{Verbatim}[commandchars=\\\{\}]
sat log \textless{}application\textgreater{} --clean 50
\end{Verbatim}

\end{itemize}


\subsection{Some useful configuration pathes}
\label{commands/log:some-useful-configuration-pathes}\begin{itemize}
\item {} 
\textbf{USER}
\begin{itemize}
\item {} 
\textbf{browser} : The browser used to show the log (by default \emph{firefox}).

\item {} 
\textbf{log\_dir} : The directory used to store the log files.

\end{itemize}

\end{itemize}


\section{Command environ}
\label{commands/environ:svn}\label{commands/environ:command-environ}\label{commands/environ::doc}

\subsection{Description}
\label{commands/environ:description}
The \textbf{environ} command generates the environment files used
to run and compile your application (as \href{http://www.salome-platform.org}{SALOME} (http://www.salome-platform.org) is an example).

\begin{notice}{note}{Note:}
these files are \textbf{not} required,
salomeTool set the environment himself, when compiling.
And so does the salome launcher.

These files are useful when someone wants to check the environment.
They could be used in debug mode to set the environment for \emph{gdb}.
\end{notice}

The configuration part at the end of this page explains how
to specify the environment used by sat (at build or run time),
and saved in some files by \emph{sat environ} command.


\subsection{Usage}
\label{commands/environ:usage}\begin{itemize}
\item {} 
Create the shell environment files of the application:

\begin{Verbatim}[commandchars=\\\{\}]
sat environ \textless{}application\textgreater{}
\end{Verbatim}

\item {} 
Create the environment files of the application for a given shell.
Options are bash, bat (for windows) and cfg (the configuration format used by \href{http://www.salome-platform.org}{SALOME} (http://www.salome-platform.org)):

\begin{Verbatim}[commandchars=\\\{\}]
sat environ \textless{}application\textgreater{} --shell [bash\textbar{}cfg\textbar{}all]
\end{Verbatim}

\item {} 
Use a different prefix for the files (default is `env'):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} This will create file \textless{}prefix\textgreater{}\PYGZus{}launch.sh, \textless{}prefix\textgreater{}\PYGZus{}build.sh}
sat environ \textless{}application\textgreater{} --prefix \textless{}prefix\textgreater{}
\end{Verbatim}

\item {} 
Use a different target directory for the files:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} This will create file env\PYGZus{}launch.sh, env\PYGZus{}build.sh}
\PYG{c}{\PYGZsh{} in the directory corresponding to \textless{}path\textgreater{}}
sat environ \textless{}application\textgreater{} --target \textless{}path\textgreater{}
\end{Verbatim}

\item {} 
Generate the environment files only with the given products:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} This will create the environment files only for the given products}
\PYG{c}{\PYGZsh{} and their prerequisites.}
\PYG{c}{\PYGZsh{} It is useful when you want to visualise which environment uses}
\PYG{c}{\PYGZsh{} sat to compile a given product.}
sat environ \textless{}application\textgreater{} --product \textless{}product1\textgreater{},\textless{}product2\textgreater{}, ...
\end{Verbatim}

\end{itemize}


\subsection{Configuration}
\label{commands/environ:configuration}
The specification of the environment can be done through several mechanisms.
\begin{enumerate}
\item {} 
For salome products (the products with the property \code{is\_SALOME\_module} as \code{yes}) the environment is set automatically by sat, in respect with \href{http://www.salome-platform.org}{SALOME} (http://www.salome-platform.org) requirements.

\item {} 
For other products, the environment is set with the use of the environ section within the pyconf file of the product. The user has two possibilities, either set directly the environment within the section, or specify a python script which wil be used to set the environment programmatically.

\end{enumerate}

Within the section, the user can define environment variables. He can also modify PATH variables, by appending or prepending directories.
In the following example, we prepend \emph{\textless{}install\_dir\textgreater{}/lib} to \code{LD\_LIBRARY\_PATH} (note the \emph{left first} underscore), append \emph{\textless{}install\_dir\textgreater{}/lib} to \code{PYTHONPATH} (note the \emph{right last} underscore), and set \code{LAPACK\_ROOT\_DIR} to \emph{\textless{}install\_dir\textgreater{}}:

\begin{Verbatim}[commandchars=\\\{\}]
environ :
\PYGZob{}
  \_LD\_LIBRARY\_PATH : \$install\_dir + \$VARS.sep + "lib"
  PYTHONPATH\_ : \$install\_dir + \$VARS.sep + "lib"
  LAPACK\_ROOT\_DIR : \$install\_dir
\PYGZcb{}
\end{Verbatim}

It is possible to distinguish the build environment from the launch environment: use a subsection called \emph{build} or \emph{launch}. In the example below, \code{LD\_LIBRARY\_PATH} and \code{PYTHONPATH} are only modified at run time, not at compile time:

\begin{Verbatim}[commandchars=\\\{\}]
environ :
\PYGZob{}
  build :
  \PYGZob{}
    LAPACK\_ROOT\_DIR : \$install\_dir
  \PYGZcb{}
  launch :
  \PYGZob{}
    LAPACK\_ROOT\_DIR : \$install\_dir
    \_LD\_LIBRARY\_PATH : \$install\_dir + \$VARS.sep + "lib"
    PYTHONPATH\_ : \$install\_dir + \$VARS.sep + "lib"
  \PYGZcb{}
\PYGZcb{}
\end{Verbatim}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
The last possibility is to set the environment with a python script. The script should be provided in the \emph{products/env\_scripts} directory of the sat project, and its name is specified in the environment section with the key \code{environ.env\_script}:

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{environ} \PYG{p}{:}
\PYG{p}{\PYGZob{}}
  \PYG{n}{env\PYGZus{}script} \PYG{p}{:} \PYG{l+s}{'}\PYG{l+s}{lapack.py}\PYG{l+s}{'}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Please note that the two modes are complementary and are both taken into account.
Most of the time, the first mode is sufficient.

The second mode can be used when the environment has to be set programmatically.
The developer implements a handle (as a python method)
which is called by sat to set the environment.
Here is an example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}!/usr/bin/env python}
\PYG{c}{\PYGZsh{}-*- coding:utf-8 -*-}

\PYG{k+kn}{import} \PYG{n+nn}{os.path}
\PYG{k+kn}{import} \PYG{n+nn}{platform}

\PYG{k}{def} \PYG{n+nf}{set\PYGZus{}env}\PYG{p}{(}\PYG{n}{env}\PYG{p}{,} \PYG{n}{prereq\PYGZus{}dir}\PYG{p}{,} \PYG{n}{version}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{env}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{TRUST\PYGZus{}ROOT\PYGZus{}DIR}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{prereq\PYGZus{}dir}\PYG{p}{)}
    \PYG{n}{env}\PYG{o}{.}\PYG{n}{prepend}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{PATH}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{prereq\PYGZus{}dir}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{bin}\PYG{l+s}{'}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{env}\PYG{o}{.}\PYG{n}{prepend}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{PATH}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{prereq\PYGZus{}dir}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{include}\PYG{l+s}{'}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{env}\PYG{o}{.}\PYG{n}{prepend}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{LD\PYGZus{}LIBRARY\PYGZus{}PATH}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{prereq\PYGZus{}dir}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{lib}\PYG{l+s}{'}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return}
\end{Verbatim}

SalomeTools defines four handles:
\begin{itemize}
\item {} 
\textbf{set\_env(env, prereq\_dir, version)} : used at build and run time.

\item {} 
\textbf{set\_env\_launch(env, prereq\_dir, version)} : used only at run time (if defined!)

\item {} 
\textbf{set\_env\_build(env, prereq\_dir, version)} : used only at build time (if defined!)

\item {} 
\textbf{set\_native\_env(env)} : used only for native products, at build and run time.

\end{itemize}


\section{Command clean}
\label{commands/clean:svn}\label{commands/clean:command-clean}\label{commands/clean::doc}

\subsection{Description}
\label{commands/clean:description}
The \textbf{clean} command removes products in the \emph{source, build, or install} directories of an application. Theses directories are usually named \code{SOURCES, BUILD, INSTALL}.

Use the options to define what directories you want to suppress and to set the list of products


\subsection{Usage}
\label{commands/clean:usage}\begin{itemize}
\item {} 
Clean all previously created \emph{build} and \emph{install} directories (example application as \emph{SALOME\_xx}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} take care, is long time to restore, sometimes}
sat clean SALOME-xx --build --install
\end{Verbatim}

\item {} 
Clean previously created \emph{build} and \emph{install} directories, only for products with property \emph{is\_salome\_module}:

\begin{Verbatim}[commandchars=\\\{\}]
sat clean SALOME-xxx --build --install \PYG{l+s+se}{\PYGZbs{}}
                     --properties is\PYGZus{}salome\PYGZus{}module:yes
\end{Verbatim}

\end{itemize}


\subsection{Availables options}
\label{commands/clean:availables-options}\begin{itemize}
\item {} 
\textbf{--products} : Products to clean.

\item {} 
\textbf{--properties} :

\begin{DUlineblock}{0em}
\item[] Filter the products by their properties.
\item[] Syntax: \emph{--properties \textless{}property\textgreater{}:\textless{}value\textgreater{}}
\end{DUlineblock}

\item {} 
\textbf{--sources} : Clean the product source directories.

\item {} 
\textbf{--build} : Clean the product build directories.

\item {} 
\textbf{--install} : Clean the product install directories.

\item {} 
\textbf{--all} : Clean the product source, build and install directories.

\item {} 
\textbf{--sources\_without\_dev} :

\begin{DUlineblock}{0em}
\item[] Do not clean the products in development mode,
\item[] (they could have \href{https://en.wikipedia.org/wiki/Version\_control}{VCS} (https://en.wikipedia.org/wiki/Version\_control) commits pending).
\end{DUlineblock}

\end{itemize}


\subsection{Some useful configuration pathes}
\label{commands/clean:some-useful-configuration-pathes}
No specific configuration.


\section{Command package}
\label{commands/package:svn}\label{commands/package:command-package}\label{commands/package::doc}

\subsection{Description}
\label{commands/package:description}
The \textbf{package} command creates a \href{http://www.salome-platform.org}{SALOME} (http://www.salome-platform.org) archive (usually a compressed \href{https://en.wikipedia.org/wiki/Tar\_(computing)}{Tar} (https://en.wikipedia.org/wiki/Tar\_(computing)) file .tgz).
This tar file is used later to intall SALOME on other remote computer.

Depending on the selected options, the archive includes sources and binaries
of SALOME products and prerequisites.

Usually utility \emph{salomeTools} is included in the archive.

\begin{notice}{note}{Note:}
By default the package includes the sources of prerequisites and products.
To select a subset use the \emph{--without\_property} or \emph{--with\_vcs} options.
\end{notice}


\subsection{Usage}
\label{commands/package:usage}\begin{itemize}
\item {} 
Create a package for a product (example as \emph{SALOME\_xx}):

\begin{Verbatim}[commandchars=\\\{\}]
sat package SALOME\_xx
\end{Verbatim}

This command will create an archive named \code{SALOME\_xx.tgz}
in the working directory (\code{USER.workDir}).
If the archive already exists, do nothing.

\item {} 
Create a package with a specific name:

\begin{Verbatim}[commandchars=\\\{\}]
sat package SALOME\_xx --name YourSpecificName
\end{Verbatim}

\end{itemize}

\begin{notice}{note}{Note:}
By default, the archive is created in the working directory of the user (\code{USER.workDir}).

If the option \emph{--name} is used with a path (relative or absolute) it will be used.

If the option \emph{--name} is not used and binaries (prerequisites and products)
are included in the package, the \href{https://en.wikipedia.org/wiki/Operating\_system}{OS} (https://en.wikipedia.org/wiki/Operating\_system) architecture
will be appended to the name (example: \code{SALOME\_xx-CO7.tgz}).

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\# Creates SALOME\_xx.tgz in \$USER.workDir
sat package SALOME\_xx

\# Creates SALOME\_xx\_\textless{}arch\textgreater{}.tgz in \$USER.workDir
sat package SALOME\_xx --binaries

\# Creates MySpecificName.tgz in \$USER.workDir
sat package SALOME\_xx --name MySpecificName
\end{Verbatim}
\end{notice}
\begin{itemize}
\item {} 
Force the creation of the archive (if it already exists):

\begin{Verbatim}[commandchars=\\\{\}]
sat package SALOME\_xx --force
\end{Verbatim}

\item {} 
Include the binaries in the archive (products and prerequisites):

\begin{Verbatim}[commandchars=\\\{\}]
sat package SALOME\_xx --binaries
\end{Verbatim}

This command will create an archive named \code{SALOME\_xx \_\textless{}arch\textgreater{}.tgz}
where \textless{}arch\textgreater{} is the \href{https://en.wikipedia.org/wiki/Operating\_system}{OS} (https://en.wikipedia.org/wiki/Operating\_system) architecture of the machine.

\item {} 
Do not delete Version Control System (\href{https://en.wikipedia.org/wiki/Version\_control}{VCS} (https://en.wikipedia.org/wiki/Version\_control)) informations from the configurations files of the embedded salomeTools:

\begin{Verbatim}[commandchars=\\\{\}]
sat package SALOME\_xx --with\_vcs
\end{Verbatim}

The version control systems known by this option are \href{https://fr.wikipedia.org/wiki/Concurrent\_versions\_system}{CVS} (https://fr.wikipedia.org/wiki/Concurrent\_versions\_system), \href{https://en.wikipedia.org/wiki/Apache\_Subversion}{SVN} (https://en.wikipedia.org/wiki/Apache\_Subversion) and \href{https://git-scm.com}{Git} (https://git-scm.com).

\end{itemize}


\subsection{Some useful configuration pathes}
\label{commands/package:some-useful-configuration-pathes}
No specific configuration.


\section{Command generate}
\label{commands/generate:svn}\label{commands/generate:command-generate}\label{commands/generate::doc}

\subsection{Description}
\label{commands/generate:description}
The \textbf{generate} command generates and compile SALOME modules from cpp modules using YACSGEN.

\begin{notice}{note}{Note:}
This command uses YACSGEN to generate the module. It needs to be specified with \emph{--yacsgen} option, or defined in the product or by the environment variable \code{\$YACSGEN\_ROOT\_DIR}.
\end{notice}


\subsection{Remarks}
\label{commands/generate:remarks}\begin{itemize}
\item {} 
This command will only apply on the CPP modules of the application, those who have both properties:

\begin{Verbatim}[commandchars=\\\{\}]
cpp : "yes"
generate : "yes"
\end{Verbatim}

\item {} 
The cpp module are usually computational components, and the generated module brings the CORBA layer which allows distributing the compononent on remore machines. cpp modules should conform to YACSGEN/hxx2salome requirements (please refer to YACSGEN documentation)

\end{itemize}


\subsection{Usage}
\label{commands/generate:usage}\begin{itemize}
\item {} 
Generate all the modules of a product:

\begin{Verbatim}[commandchars=\\\{\}]
sat generate \textless{}application\textgreater{}
\end{Verbatim}

\item {} 
Generate only specific modules:

\begin{Verbatim}[commandchars=\\\{\}]
sat generate \textless{}application\textgreater{} --products \textless{}list\_of\_products\textgreater{}
\end{Verbatim}

Remark: modules which don't have the \emph{generate} property are ignored.

\item {} 
Use a specific version of YACSGEN:

\begin{Verbatim}[commandchars=\\\{\}]
sat generate \textless{}application\textgreater{} --yacsgen \textless{}path\_to\_yacsgen\textgreater{}
\end{Verbatim}

\end{itemize}


\chapter{Developer documentation}
\label{index:developer-documentation}

\section{Add a user custom command}
\label{write_command:svn}\label{write_command:add-a-user-custom-command}\label{write_command::doc}

\subsection{Introduction}
\label{write_command:introduction}
\begin{notice}{note}{Note:}
This documentation is for \href{https://docs.python.org/2.7}{Python} (https://docs.python.org/2.7) developers.
\end{notice}

The salomeTools product provides a simple way to develop commands.
The first thing to do is to add a file with \emph{.py} extension in the \code{commands} directory of salomeTools.

Here are the basic requirements that must be followed in this file in order to add a command.


\subsection{Basic requirements}
\label{write_command:basic-requirements}
By adding a file \emph{mycommand.py} in the \code{commands} directory, salomeTools will define a new command named \code{mycommand}.

In \emph{mycommand.py}, there must be the following method:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n}{args}\PYG{p}{,} \PYG{n}{runner}\PYG{p}{,} \PYG{n}{logger}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} your algorithm ...}
    \PYG{k}{pass}
\end{Verbatim}

In fact, at this point, the command will already be functional.
But there are some useful services provided by salomeTools :
\begin{itemize}
\item {} 
You can give some options to your command:

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{src}

\PYG{c}{\PYGZsh{} Define all possible option for mycommand command :  'sat mycommand \textless{}options\textgreater{}'}
\PYG{n}{parser} \PYG{o}{=} \PYG{n}{src}\PYG{o}{.}\PYG{n}{options}\PYG{o}{.}\PYG{n}{Options}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}option}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{m}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{myoption}\PYG{l+s}{'}\PYG{p}{,} \PYGZbs{}
                  \PYG{l+s}{'}\PYG{l+s}{boolean}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{myoption}\PYG{l+s}{'}\PYG{p}{,} \PYGZbs{}
                  \PYG{l+s}{'}\PYG{l+s}{My option changes the behavior of my command.}\PYG{l+s}{'}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n}{args}\PYG{p}{,} \PYG{n}{runner}\PYG{p}{,} \PYG{n}{logger}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} Parse the options}
    \PYG{p}{(}\PYG{n}{options}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)} \PYG{o}{=} \PYG{n}{parser}\PYG{o}{.}\PYG{n}{parse\PYGZus{}args}\PYG{p}{(}\PYG{n}{args}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} algorithm}
\end{Verbatim}
\begin{itemize}
\item {} 
You can add a \emph{description} method that will display a message when the user will call the help:

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
 \PYG{k+kn}{import} \PYG{n+nn}{src}

 \PYG{c}{\PYGZsh{} Define all possible option for mycommand command : 'sat mycommand \textless{}options\textgreater{}'}
 \PYG{n}{parser} \PYG{o}{=} \PYG{n}{src}\PYG{o}{.}\PYG{n}{options}\PYG{o}{.}\PYG{n}{Options}\PYG{p}{(}\PYG{p}{)}
 \PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}option}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{m}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{myoption}\PYG{l+s}{'}\PYG{p}{,} \PYGZbs{}
                   \PYG{l+s}{'}\PYG{l+s}{boolean}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{myoption}\PYG{l+s}{'}\PYG{p}{,} \PYGZbs{}
                   \PYG{l+s}{'}\PYG{l+s}{My option changes the behavior of my command.}\PYG{l+s}{'}\PYG{p}{)}

 \PYG{k}{def} \PYG{n+nf}{description}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
     \PYG{k}{return} \PYG{n}{\PYGZus{}}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{The help of mycommand.}\PYG{l+s}{"}\PYG{p}{)}

 \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n}{args}\PYG{p}{,} \PYG{n}{runner}\PYG{p}{,} \PYG{n}{logger}\PYG{p}{)}\PYG{p}{:}
     \PYG{c}{\PYGZsh{} Parse the options}
     \PYG{p}{(}\PYG{n}{options}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)} \PYG{o}{=} \PYG{n}{parser}\PYG{o}{.}\PYG{n}{parse\PYGZus{}args}\PYG{p}{(}\PYG{n}{args}\PYG{p}{)}
     \PYG{c}{\PYGZsh{} algorithm}
\end{Verbatim}


\subsection{HowTo access salomeTools config and other commands}
\label{write_command:howto-access-salometools-config-and-other-commands}
The \emph{runner} variable is an python instance of \emph{Sat} class.
It gives access to \emph{runner.cfg} which is the data model defined from all
\emph{configuration pyconf files} of salomeTools
For example, \emph{runner.cfg.APPLICATION.workdir}
contains the root directory of the current application.

The \emph{runner} variable gives also access to other commands of salomeTools:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} as CLI\PYGZus{} 'sat prepare ...'}
\PYG{n}{runner}\PYG{o}{.}\PYG{n}{prepare}\PYG{p}{(}\PYG{n}{runner}\PYG{o}{.}\PYG{n}{cfg}\PYG{o}{.}\PYG{n}{VARS}\PYG{o}{.}\PYG{n}{application}\PYG{p}{)}
\end{Verbatim}


\subsection{HowTo logger}
\label{write_command:howto-logger}
The logger variable is an instance of the Logger class.
It gives access to the write method.

When this method is called, the message passed as parameter
will be displayed in the terminal and written in an xml log file.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{logger}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{My message}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{c}{\PYGZsh{} 3 as default}
\end{Verbatim}

The second argument defines the level of verbosity
that is wanted for this message.
It has to be between 1 and 5 (the most verbose level).


\subsection{HELLO example}
\label{write_command:hello-example}
Here is a \emph{hello} command, file \emph{commands/hello.py}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{src}

\PYG{l+s+sd}{"""}
\PYG{l+s+sd}{hello.py}
\PYG{l+s+sd}{Define all possible options for hello command:}
\PYG{l+s+sd}{sat hello \textless{}options\textgreater{}}
\PYG{l+s+sd}{"""}

\PYG{n}{parser} \PYG{o}{=} \PYG{n}{src}\PYG{o}{.}\PYG{n}{options}\PYG{o}{.}\PYG{n}{Options}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}option}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{f}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{french}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{boolean}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{french}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{french set hello message in french.}\PYG{l+s}{"}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{description}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{\PYGZus{}}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{The help of hello.}\PYG{l+s}{"}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n}{args}\PYG{p}{,} \PYG{n}{runner}\PYG{p}{,} \PYG{n}{logger}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} Parse the options}
    \PYG{p}{(}\PYG{n}{options}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)} \PYG{o}{=} \PYG{n}{parser}\PYG{o}{.}\PYG{n}{parse\PYGZus{}args}\PYG{p}{(}\PYG{n}{args}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} algorithm}
    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{options}\PYG{o}{.}\PYG{n}{french}\PYG{p}{:}
        \PYG{n}{logger}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{HELLO! WORLD!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{logger}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{Bonjour tout le monde!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

A first call of hello:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Get the help of hello:}
./sat --help hello

\PYG{c}{\PYGZsh{} To get bonjour}
./sat hello --french
Bonjour tout le monde!

\PYG{c}{\PYGZsh{} To get hello}
./sat hello
HELLO! WORLD!

\PYG{c}{\PYGZsh{} To get the log}
./sat log
\end{Verbatim}


\chapter{Code documentation}
\label{index:code-documentation}

\section{src}
\label{commands/apidoc/modules:src}\label{commands/apidoc/modules::doc}

\subsection{src Package}
\label{commands/apidoc/src::doc}\label{commands/apidoc/src:src-package}

\subsubsection{\texttt{src} Package}
\label{commands/apidoc/src:id1}\phantomsection\label{commands/apidoc/src:module-src.__init__}\index{src.\_\_init\_\_ (module)}
initial imports and utilities methods for salomeTools
\index{Path (class in src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path}\pysiglinewithargsret{\strong{class }\code{src.\_\_init\_\_.}\bfcode{Path}}{\emph{path}}{}~\index{base() (src.\_\_init\_\_.Path method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path.base}\pysiglinewithargsret{\bfcode{base}}{}{}
\end{fulllineitems}

\index{chmod() (src.\_\_init\_\_.Path method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path.chmod}\pysiglinewithargsret{\bfcode{chmod}}{\emph{mode}}{}
\end{fulllineitems}

\index{copy() (src.\_\_init\_\_.Path method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path.copy}\pysiglinewithargsret{\bfcode{copy}}{\emph{path}, \emph{smart=False}}{}
\end{fulllineitems}

\index{copydir() (src.\_\_init\_\_.Path method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path.copydir}\pysiglinewithargsret{\bfcode{copydir}}{\emph{dst}, \emph{smart=False}}{}
\end{fulllineitems}

\index{copyfile() (src.\_\_init\_\_.Path method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path.copyfile}\pysiglinewithargsret{\bfcode{copyfile}}{\emph{path}}{}
\end{fulllineitems}

\index{copylink() (src.\_\_init\_\_.Path method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path.copylink}\pysiglinewithargsret{\bfcode{copylink}}{\emph{path}}{}
\end{fulllineitems}

\index{dir() (src.\_\_init\_\_.Path method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path.dir}\pysiglinewithargsret{\bfcode{dir}}{}{}
\end{fulllineitems}

\index{exists() (src.\_\_init\_\_.Path method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path.exists}\pysiglinewithargsret{\bfcode{exists}}{}{}
\end{fulllineitems}

\index{isdir() (src.\_\_init\_\_.Path method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path.isdir}\pysiglinewithargsret{\bfcode{isdir}}{}{}
\end{fulllineitems}

\index{isfile() (src.\_\_init\_\_.Path method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path.isfile}\pysiglinewithargsret{\bfcode{isfile}}{}{}
\end{fulllineitems}

\index{islink() (src.\_\_init\_\_.Path method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path.islink}\pysiglinewithargsret{\bfcode{islink}}{}{}
\end{fulllineitems}

\index{list() (src.\_\_init\_\_.Path method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path.list}\pysiglinewithargsret{\bfcode{list}}{}{}
\end{fulllineitems}

\index{make() (src.\_\_init\_\_.Path method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path.make}\pysiglinewithargsret{\bfcode{make}}{\emph{mode=None}}{}
\end{fulllineitems}

\index{readlink() (src.\_\_init\_\_.Path method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path.readlink}\pysiglinewithargsret{\bfcode{readlink}}{}{}
\end{fulllineitems}

\index{rm() (src.\_\_init\_\_.Path method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path.rm}\pysiglinewithargsret{\bfcode{rm}}{}{}
\end{fulllineitems}

\index{smartcopy() (src.\_\_init\_\_.Path method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path.smartcopy}\pysiglinewithargsret{\bfcode{smartcopy}}{\emph{path}}{}
\end{fulllineitems}

\index{symlink() (src.\_\_init\_\_.Path method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.Path.symlink}\pysiglinewithargsret{\bfcode{symlink}}{\emph{path}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{SatException}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.SatException}\pysigline{\strong{exception }\code{src.\_\_init\_\_.}\bfcode{SatException}}
Bases: \code{exceptions.Exception}

rename Exception Class

\end{fulllineitems}

\index{activate\_mesa\_property() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.activate_mesa_property}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{activate\_mesa\_property}}{\emph{config}}{}
Add mesa property into application properties
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{config}) -- The global configuration. It must have an application!

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_config\_has\_application() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.check_config_has_application}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{check\_config\_has\_application}}{\emph{config}, \emph{details=None}}{}
check that the config has the key APPLICATION. Else raise an exception.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{class `common.pyconf.Config'} (\emph{config}) -- The config.

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_config\_has\_profile() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.check_config_has_profile}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{check\_config\_has\_profile}}{\emph{config}, \emph{details=None}}{}
check that the config has the key APPLICATION.profile.
else, raise an exception.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{class `common.pyconf.Config'} (\emph{config}) -- The config.

\end{description}\end{quote}

\end{fulllineitems}

\index{config\_has\_application() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.config_has_application}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{config\_has\_application}}{\emph{config}}{}
\end{fulllineitems}

\index{deepcopy\_list() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.deepcopy_list}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{deepcopy\_list}}{\emph{input\_list}}{}
Do a deep copy of a list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{List} (\emph{input\_list}) -- The list to copy

\item[{Returns}] \leavevmode
The copy of the list

\item[{Return type}] \leavevmode
List

\end{description}\end{quote}

\end{fulllineitems}

\index{ensure\_path\_exists() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.ensure_path_exists}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{ensure\_path\_exists}}{\emph{p}}{}
Create a path if not existing
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{p}) -- The path.

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_file\_in\_lpath() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.find_file_in_lpath}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{find\_file\_in\_lpath}}{\emph{file\_name}, \emph{lpath}, \emph{additional\_dir='`}}{}
Find in all the directories in lpath list the file that has the same name
as file\_name. 
If it is found 
then return the full path of the file
else return False.

The additional\_dir (optional) is the name of the directory to add to all 
paths in lpath.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{additional\_dir}) -- The file name to search

\item {} 
\textbf{List} (\emph{lpath}) -- The list of directories where to search

\item {} 
\textbf{str} -- The name of the additional directory

\end{itemize}

\item[{Returns}] \leavevmode
the full path of the file or False if not found

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_base\_path() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.get_base_path}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{get\_base\_path}}{\emph{config}}{}
Returns the path of the products base.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{config}) -- The global Config instance.

\item[{Returns}] \leavevmode
The path of the products base.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_cfg\_param() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.get_cfg_param}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{get\_cfg\_param}}{\emph{config}, \emph{param\_name}, \emph{default}}{}
eearch for param\_name value in config.
if param\_name is not in config 
then return default,
else return the found value
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{class `common.pyconf.Config'} (\emph{config}) -- The config.

\item {} 
\textbf{str} (\emph{default}) -- the name of the parameter to get the value

\item {} 
\textbf{str} -- The value to return if param\_name is not in config

\end{itemize}

\item[{Returns}] \leavevmode
see initial description of the function

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_launcher\_name() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.get_launcher_name}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{get\_launcher\_name}}{\emph{config}}{}
Returns the name of salome launcher.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{config}) -- The global Config instance.

\item[{Returns}] \leavevmode
The name of salome launcher.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_log\_path() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.get_log_path}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{get\_log\_path}}{\emph{config}}{}
Returns the path of the logs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{config}) -- The global Config instance.

\item[{Returns}] \leavevmode
The path of the logs.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_property\_in\_product\_cfg() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.get_property_in_product_cfg}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{get\_property\_in\_product\_cfg}}{\emph{product\_cfg}, \emph{pprty}}{}
\end{fulllineitems}

\index{get\_salome\_version() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.get_salome_version}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{get\_salome\_version}}{\emph{config}}{}
\end{fulllineitems}

\index{get\_tmp\_filename() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.get_tmp_filename}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{get\_tmp\_filename}}{\emph{cfg}, \emph{name}}{}
\end{fulllineitems}

\index{handleRemoveReadonly() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.handleRemoveReadonly}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{handleRemoveReadonly}}{\emph{func}, \emph{path}, \emph{exc}}{}
\end{fulllineitems}

\index{merge\_dicts() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.merge_dicts}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{merge\_dicts}}{\emph{*dict\_args}}{}
Given any number of dicts, shallow copy and merge into a new dict,
precedence goes to key value pairs in latter dicts.

\end{fulllineitems}

\index{only\_numbers() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.only_numbers}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{only\_numbers}}{\emph{str\_num}}{}
\end{fulllineitems}

\index{parse\_date() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.parse_date}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{parse\_date}}{\emph{date}}{}
Transform YYYYMMDD\_hhmmss into YYYY-MM-DD hh:mm:ss.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{date}) -- The date to transform

\item[{Returns}] \leavevmode
The date in the new format

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_info() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.print_info}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{print\_info}}{\emph{logger}, \emph{info}}{}
Prints the tuples that are in info variable in a formatted way.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Logger} (\emph{logger}) -- The logging instance to use for the prints.

\item {} 
\textbf{list} (\emph{info}) -- The list of tuples to display

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_config\_from\_a\_file() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.read_config_from_a_file}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{read\_config\_from\_a\_file}}{\emph{filePath}}{}
\end{fulllineitems}

\index{remove\_item\_from\_list() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.remove_item_from_list}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{remove\_item\_from\_list}}{\emph{input\_list}, \emph{item}}{}
Remove all occurences of item from input\_list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{List} (\emph{input\_list}) -- The list to modify

\item[{Returns}] \leavevmode
The without any item

\item[{Return type}] \leavevmode
List

\end{description}\end{quote}

\end{fulllineitems}

\index{replace\_in\_file() (in module src.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.__init__.replace_in_file}\pysiglinewithargsret{\code{src.\_\_init\_\_.}\bfcode{replace\_in\_file}}{\emph{filein}, \emph{strin}, \emph{strout}}{}
Replace \textless{}strin\textgreater{} by \textless{}strout\textgreater{} in file \textless{}filein\textgreater{}

\end{fulllineitems}



\subsubsection{\texttt{ElementTree} Module}
\label{commands/apidoc/src:elementtree-module}\label{commands/apidoc/src:module-src.ElementTree}\index{src.ElementTree (module)}\index{Comment() (in module src.ElementTree)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.Comment}\pysiglinewithargsret{\code{src.ElementTree.}\bfcode{Comment}}{\emph{text=None}}{}
\end{fulllineitems}

\index{dump() (in module src.ElementTree)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.dump}\pysiglinewithargsret{\code{src.ElementTree.}\bfcode{dump}}{\emph{elem}}{}
\end{fulllineitems}

\index{Element() (in module src.ElementTree)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.Element}\pysiglinewithargsret{\code{src.ElementTree.}\bfcode{Element}}{\emph{tag}, \emph{attrib=\{\}}, \emph{**extra}}{}
\end{fulllineitems}

\index{ElementTree (class in src.ElementTree)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.ElementTree}\pysiglinewithargsret{\strong{class }\code{src.ElementTree.}\bfcode{ElementTree}}{\emph{element=None}, \emph{file=None}}{}~\index{find() (src.ElementTree.ElementTree method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.ElementTree.find}\pysiglinewithargsret{\bfcode{find}}{\emph{path}}{}
\end{fulllineitems}

\index{findall() (src.ElementTree.ElementTree method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.ElementTree.findall}\pysiglinewithargsret{\bfcode{findall}}{\emph{path}}{}
\end{fulllineitems}

\index{findtext() (src.ElementTree.ElementTree method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.ElementTree.findtext}\pysiglinewithargsret{\bfcode{findtext}}{\emph{path}, \emph{default=None}}{}
\end{fulllineitems}

\index{getiterator() (src.ElementTree.ElementTree method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.ElementTree.getiterator}\pysiglinewithargsret{\bfcode{getiterator}}{\emph{tag=None}}{}
\end{fulllineitems}

\index{getroot() (src.ElementTree.ElementTree method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.ElementTree.getroot}\pysiglinewithargsret{\bfcode{getroot}}{}{}
\end{fulllineitems}

\index{parse() (src.ElementTree.ElementTree method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.ElementTree.parse}\pysiglinewithargsret{\bfcode{parse}}{\emph{source}, \emph{parser=None}}{}
\end{fulllineitems}

\index{write() (src.ElementTree.ElementTree method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.ElementTree.write}\pysiglinewithargsret{\bfcode{write}}{\emph{file}, \emph{encoding='us-ascii'}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{fromstring() (in module src.ElementTree)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.fromstring}\pysiglinewithargsret{\code{src.ElementTree.}\bfcode{fromstring}}{\emph{text}}{}
\end{fulllineitems}

\index{iselement() (in module src.ElementTree)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.iselement}\pysiglinewithargsret{\code{src.ElementTree.}\bfcode{iselement}}{\emph{element}}{}
\end{fulllineitems}

\index{iterparse (class in src.ElementTree)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.iterparse}\pysiglinewithargsret{\strong{class }\code{src.ElementTree.}\bfcode{iterparse}}{\emph{source}, \emph{events=None}}{}~\index{next() (src.ElementTree.iterparse method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.iterparse.next}\pysiglinewithargsret{\bfcode{next}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{parse() (in module src.ElementTree)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.parse}\pysiglinewithargsret{\code{src.ElementTree.}\bfcode{parse}}{\emph{source}, \emph{parser=None}}{}
\end{fulllineitems}

\index{PI() (in module src.ElementTree)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.PI}\pysiglinewithargsret{\code{src.ElementTree.}\bfcode{PI}}{\emph{target}, \emph{text=None}}{}
\end{fulllineitems}

\index{ProcessingInstruction() (in module src.ElementTree)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.ProcessingInstruction}\pysiglinewithargsret{\code{src.ElementTree.}\bfcode{ProcessingInstruction}}{\emph{target}, \emph{text=None}}{}
\end{fulllineitems}

\index{QName (class in src.ElementTree)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.QName}\pysiglinewithargsret{\strong{class }\code{src.ElementTree.}\bfcode{QName}}{\emph{text\_or\_uri}, \emph{tag=None}}{}
\end{fulllineitems}

\index{SubElement() (in module src.ElementTree)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.SubElement}\pysiglinewithargsret{\code{src.ElementTree.}\bfcode{SubElement}}{\emph{parent}, \emph{tag}, \emph{attrib=\{\}}, \emph{**extra}}{}
\end{fulllineitems}

\index{tostring() (in module src.ElementTree)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.tostring}\pysiglinewithargsret{\code{src.ElementTree.}\bfcode{tostring}}{\emph{element}, \emph{encoding=None}}{}
\end{fulllineitems}

\index{TreeBuilder (class in src.ElementTree)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.TreeBuilder}\pysiglinewithargsret{\strong{class }\code{src.ElementTree.}\bfcode{TreeBuilder}}{\emph{element\_factory=None}}{}~\index{close() (src.ElementTree.TreeBuilder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.TreeBuilder.close}\pysiglinewithargsret{\bfcode{close}}{}{}
\end{fulllineitems}

\index{data() (src.ElementTree.TreeBuilder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.TreeBuilder.data}\pysiglinewithargsret{\bfcode{data}}{\emph{data}}{}
\end{fulllineitems}

\index{end() (src.ElementTree.TreeBuilder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.TreeBuilder.end}\pysiglinewithargsret{\bfcode{end}}{\emph{tag}}{}
\end{fulllineitems}

\index{start() (src.ElementTree.TreeBuilder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.TreeBuilder.start}\pysiglinewithargsret{\bfcode{start}}{\emph{tag}, \emph{attrs}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{XML() (in module src.ElementTree)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.XML}\pysiglinewithargsret{\code{src.ElementTree.}\bfcode{XML}}{\emph{text}}{}
\end{fulllineitems}

\index{XMLTreeBuilder (class in src.ElementTree)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.XMLTreeBuilder}\pysiglinewithargsret{\strong{class }\code{src.ElementTree.}\bfcode{XMLTreeBuilder}}{\emph{html=0}, \emph{target=None}}{}~\index{close() (src.ElementTree.XMLTreeBuilder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.XMLTreeBuilder.close}\pysiglinewithargsret{\bfcode{close}}{}{}
\end{fulllineitems}

\index{doctype() (src.ElementTree.XMLTreeBuilder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.XMLTreeBuilder.doctype}\pysiglinewithargsret{\bfcode{doctype}}{\emph{name}, \emph{pubid}, \emph{system}}{}
\end{fulllineitems}

\index{feed() (src.ElementTree.XMLTreeBuilder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.ElementTree.XMLTreeBuilder.feed}\pysiglinewithargsret{\bfcode{feed}}{\emph{data}}{}
\end{fulllineitems}


\end{fulllineitems}



\subsubsection{\texttt{architecture} Module}
\label{commands/apidoc/src:architecture-module}\label{commands/apidoc/src:module-src.architecture}\index{src.architecture (module)}
In this file : all the stuff that can change with the architecture 
on which SAT is running
\index{get\_distrib\_version() (in module src.architecture)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.architecture.get_distrib_version}\pysiglinewithargsret{\code{src.architecture.}\bfcode{get\_distrib\_version}}{\emph{distrib}, \emph{codes}}{}
Gets the version of the distribution
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{distrib}) -- The distribution on which the version will be found.

\item {} 
\textbf{L\{Mapping\}} (\emph{codes}) -- The map containing distribution correlation table.

\end{itemize}

\item[{Returns}] \leavevmode
The version of the distribution on which salomeTools is running, 
regarding the distribution correlation table contained in codes 
variable.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_distribution() (in module src.architecture)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.architecture.get_distribution}\pysiglinewithargsret{\code{src.architecture.}\bfcode{get\_distribution}}{\emph{codes}}{}
Gets the code for the distribution
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{L\{Mapping\}} (\emph{codes}) -- The map containing distribution correlation table.

\item[{Returns}] \leavevmode
The distribution on which salomeTools is running, regarding the 
distribution correlation table contained in codes variable.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_nb\_proc() (in module src.architecture)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.architecture.get_nb_proc}\pysiglinewithargsret{\code{src.architecture.}\bfcode{get\_nb\_proc}}{}{}
Gets the number of processors of the machine 
on which salomeTools is running.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the number of processors.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_python\_version() (in module src.architecture)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.architecture.get_python_version}\pysiglinewithargsret{\code{src.architecture.}\bfcode{get\_python\_version}}{}{}
Gets the version of the running python.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the version of the running python.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_user() (in module src.architecture)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.architecture.get_user}\pysiglinewithargsret{\code{src.architecture.}\bfcode{get\_user}}{}{}
method that gets the username that launched sat
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_windows() (in module src.architecture)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.architecture.is_windows}\pysiglinewithargsret{\code{src.architecture.}\bfcode{is\_windows}}{}{}
method that checks windows OS
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{\texttt{compilation} Module}
\label{commands/apidoc/src:module-src.compilation}\label{commands/apidoc/src:compilation-module}\index{src.compilation (module)}\index{Builder (class in src.compilation)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder}\pysiglinewithargsret{\strong{class }\code{src.compilation.}\bfcode{Builder}}{\emph{config}, \emph{logger}, \emph{product\_info}, \emph{options=\textless{}src.options.OptResult object at 0x245afd0\textgreater{}}, \emph{check\_src=True}}{}
Class to handle all construction steps, like cmake, configure, make, ...
\index{build\_configure() (src.compilation.Builder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder.build_configure}\pysiglinewithargsret{\bfcode{build\_configure}}{\emph{options='`}}{}
\end{fulllineitems}

\index{check() (src.compilation.Builder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder.check}\pysiglinewithargsret{\bfcode{check}}{\emph{command='`}}{}
\end{fulllineitems}

\index{cmake() (src.compilation.Builder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder.cmake}\pysiglinewithargsret{\bfcode{cmake}}{\emph{options='`}}{}
\end{fulllineitems}

\index{complete\_environment() (src.compilation.Builder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder.complete_environment}\pysiglinewithargsret{\bfcode{complete\_environment}}{\emph{make\_options}}{}
\end{fulllineitems}

\index{configure() (src.compilation.Builder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder.configure}\pysiglinewithargsret{\bfcode{configure}}{\emph{options='`}}{}
\end{fulllineitems}

\index{do\_batch\_script\_build() (src.compilation.Builder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder.do_batch_script_build}\pysiglinewithargsret{\bfcode{do\_batch\_script\_build}}{\emph{script}, \emph{nb\_proc}}{}
\end{fulllineitems}

\index{do\_default\_build() (src.compilation.Builder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder.do_default_build}\pysiglinewithargsret{\bfcode{do\_default\_build}}{\emph{build\_conf\_options='`}, \emph{configure\_options='`}, \emph{show\_warning=True}}{}
\end{fulllineitems}

\index{do\_python\_script\_build() (src.compilation.Builder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder.do_python_script_build}\pysiglinewithargsret{\bfcode{do\_python\_script\_build}}{\emph{script}, \emph{nb\_proc}}{}
\end{fulllineitems}

\index{do\_script\_build() (src.compilation.Builder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder.do_script_build}\pysiglinewithargsret{\bfcode{do\_script\_build}}{\emph{script}, \emph{number\_of\_proc=0}}{}
\end{fulllineitems}

\index{hack\_libtool() (src.compilation.Builder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder.hack_libtool}\pysiglinewithargsret{\bfcode{hack\_libtool}}{}{}
\end{fulllineitems}

\index{install() (src.compilation.Builder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder.install}\pysiglinewithargsret{\bfcode{install}}{}{}
\end{fulllineitems}

\index{log() (src.compilation.Builder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder.log}\pysiglinewithargsret{\bfcode{log}}{\emph{text}, \emph{level}, \emph{showInfo=True}}{}
\end{fulllineitems}

\index{log\_command() (src.compilation.Builder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder.log_command}\pysiglinewithargsret{\bfcode{log\_command}}{\emph{command}}{}
\end{fulllineitems}

\index{make() (src.compilation.Builder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder.make}\pysiglinewithargsret{\bfcode{make}}{\emph{nb\_proc}, \emph{make\_opt='`}}{}
\end{fulllineitems}

\index{prepare() (src.compilation.Builder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder.prepare}\pysiglinewithargsret{\bfcode{prepare}}{}{}
\end{fulllineitems}

\index{put\_txt\_log\_in\_appli\_log\_dir() (src.compilation.Builder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder.put_txt_log_in_appli_log_dir}\pysiglinewithargsret{\bfcode{put\_txt\_log\_in\_appli\_log\_dir}}{\emph{file\_name}}{}
Put the txt log (that contain the system logs, like make command
output) in the directory \textless{}APPLICATION DIR\textgreater{}/LOGS/\textless{}product\_name\textgreater{}/
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Str} (\emph{file\_name}) -- the name of the file to write

\end{description}\end{quote}

\end{fulllineitems}

\index{wmake() (src.compilation.Builder method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.compilation.Builder.wmake}\pysiglinewithargsret{\bfcode{wmake}}{\emph{nb\_proc}, \emph{opt\_nb\_proc=None}}{}
\end{fulllineitems}


\end{fulllineitems}



\subsubsection{\texttt{debug} Module}
\label{commands/apidoc/src:module-src.debug}\label{commands/apidoc/src:debug-module}\index{src.debug (module)}
This file assume DEBUG functionalities use
\begin{itemize}
\item {} 
print debug messages in sys.stderr for salomeTools

\item {} 
show pretty print debug representation from instances of SAT classes
(pretty print src.pyconf.Config), and python dict/list etc. (as `aVariable')

\end{itemize}

WARNING: obviously supposedly show messages in SAT development phase, not production

usage:
\textgreater{}\textgreater{} import debug as DBG
\textgreater{}\textgreater{} DBG.write(``aTitle'', aVariable)        \# not shown in production 
\textgreater{}\textgreater{} DBG.write(``aTitle'', aVariable, True)  \# unconditionaly shown (as show=True)

to set show message as development phase:
\textgreater{}\textgreater{} DBG.push\_debug(True)

to set no show message as production phase:
\textgreater{}\textgreater{} DBG.push\_debug(False)

to set show message temporary as development phase, only in a method:
\textgreater{}\textgreater{} def aMethodToDebug(...):
\textgreater{}\textgreater{}   DBG.push\_debug(True)              \#force show as appended status
\textgreater{}\textgreater{}   etc. method code with some DBG.write()
\textgreater{}\textgreater{}   DBG.pop\_debug()                   \#restore previous status (show or not show)
\textgreater{}\textgreater{}   return

to set a message for future fix, as temporary problem to not forget:
DBG.tofix(``aTitle'', aVariable, True/False) \#True/False in production shown, or not

in command line interface you could redirect stderr to file `myDebug.log':
\textgreater{}\textgreater{} sat compile ... 2\textgreater{} myDebug.log   \# only stderr
\textgreater{}\textgreater{} sat compile ... \&\textgreater{} myDebug.log   \# stdout and stderr
\index{InStream (class in src.debug)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.debug.InStream}\pysiglinewithargsret{\strong{class }\code{src.debug.}\bfcode{InStream}}{\emph{buf='`}}{}
Bases: \code{StringIO.StringIO}

utility class for pyconf.Config input iostream

\end{fulllineitems}

\index{OutStream (class in src.debug)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.debug.OutStream}\pysiglinewithargsret{\strong{class }\code{src.debug.}\bfcode{OutStream}}{\emph{buf='`}}{}
Bases: \code{StringIO.StringIO}

utility class for pyconf.Config output iostream
\index{close() (src.debug.OutStream method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.debug.OutStream.close}\pysiglinewithargsret{\bfcode{close}}{}{}
because Config.\_\_save\_\_ calls close() stream as file
keep value before lost as self.value

\end{fulllineitems}


\end{fulllineitems}

\index{getLocalEnv() (in module src.debug)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.debug.getLocalEnv}\pysiglinewithargsret{\code{src.debug.}\bfcode{getLocalEnv}}{}{}
get string for environment variables representation

\end{fulllineitems}

\index{getStrConfigDbg() (in module src.debug)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.debug.getStrConfigDbg}\pysiglinewithargsret{\code{src.debug.}\bfcode{getStrConfigDbg}}{\emph{config}}{}
set string as saveConfigDbg, 
as (path expression evaluation) for debug

\end{fulllineitems}

\index{getStrConfigStd() (in module src.debug)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.debug.getStrConfigStd}\pysiglinewithargsret{\code{src.debug.}\bfcode{getStrConfigStd}}{\emph{config}}{}
set string as saveConfigStd, as file .pyconf

\end{fulllineitems}

\index{indent() (in module src.debug)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.debug.indent}\pysiglinewithargsret{\code{src.debug.}\bfcode{indent}}{\emph{text}, \emph{amount=2}, \emph{ch=' `}}{}
indent multi lines message

\end{fulllineitems}

\index{pop\_debug() (in module src.debug)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.debug.pop_debug}\pysiglinewithargsret{\code{src.debug.}\bfcode{pop\_debug}}{}{}
restore previous debug outputs status

\end{fulllineitems}

\index{push\_debug() (in module src.debug)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.debug.push_debug}\pysiglinewithargsret{\code{src.debug.}\bfcode{push\_debug}}{\emph{aBool}}{}
set debug outputs activated, or not

\end{fulllineitems}

\index{saveConfigDbg() (in module src.debug)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.debug.saveConfigDbg}\pysiglinewithargsret{\code{src.debug.}\bfcode{saveConfigDbg}}{\emph{config}, \emph{aStream}, \emph{indent=0}, \emph{path='`}}{}
pyconf returns multilines (path expression evaluation) for debug

\end{fulllineitems}

\index{saveConfigStd() (in module src.debug)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.debug.saveConfigStd}\pysiglinewithargsret{\code{src.debug.}\bfcode{saveConfigStd}}{\emph{config}, \emph{aStream}}{}
returns as file .pyconf

\end{fulllineitems}

\index{tofix() (in module src.debug)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.debug.tofix}\pysiglinewithargsret{\code{src.debug.}\bfcode{tofix}}{\emph{title}, \emph{var='`}, \emph{force=None}}{}
write sys.stderr a message if \_debug{[}-1{]}==True or optionaly force=True
use this only if no logger accessible for classic 
logger.warning(message) or logger.debug(message)

\end{fulllineitems}

\index{write() (in module src.debug)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.debug.write}\pysiglinewithargsret{\code{src.debug.}\bfcode{write}}{\emph{title}, \emph{var='`}, \emph{force=None}, \emph{fmt='\textbackslash{}n\#\#\#\# DEBUG: \%s:\textbackslash{}n\%s\textbackslash{}n'}}{}
write sys.stderr a message if \_debug{[}-1{]}==True or optionaly force=True

\end{fulllineitems}



\subsubsection{\texttt{environment} Module}
\label{commands/apidoc/src:environment-module}\label{commands/apidoc/src:module-src.environment}\index{src.environment (module)}\index{Environ (class in src.environment)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.Environ}\pysiglinewithargsret{\strong{class }\code{src.environment.}\bfcode{Environ}}{\emph{environ=None}}{}
Class to manage the environment context
\index{append() (src.environment.Environ method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.Environ.append}\pysiglinewithargsret{\bfcode{append}}{\emph{key}, \emph{value}, \emph{sep=':'}}{}
Same as append\_value but the value argument can be a list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{sep}) -- the environment variable to append

\item {} 
\textbf{str or list} (\emph{value}) -- the value(s) to append to key

\item {} 
\textbf{str} -- the separator string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{append\_value() (src.environment.Environ method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.Environ.append_value}\pysiglinewithargsret{\bfcode{append\_value}}{\emph{key}, \emph{value}, \emph{sep=':'}}{}
append value to key using sep
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{sep}) -- the environment variable to append

\item {} 
\textbf{str} -- the value to append to key

\item {} 
\textbf{str} -- the separator string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{command\_value() (src.environment.Environ method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.Environ.command_value}\pysiglinewithargsret{\bfcode{command\_value}}{\emph{key}, \emph{command}}{}
Get the value given by the system command ``command'' 
and put it in the environment variable key
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{command}) -- the environment variable

\item {} 
\textbf{str} -- the command to execute

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get() (src.environment.Environ method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.Environ.get}\pysiglinewithargsret{\bfcode{get}}{\emph{key}}{}
Get the value of the environment variable ``key''
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{key}) -- the environment variable

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_defined() (src.environment.Environ method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.Environ.is_defined}\pysiglinewithargsret{\bfcode{is\_defined}}{\emph{key}}{}
Check if the key exists in the environment
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{key}) -- the environment variable to check

\end{description}\end{quote}

\end{fulllineitems}

\index{prepend() (src.environment.Environ method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.Environ.prepend}\pysiglinewithargsret{\bfcode{prepend}}{\emph{key}, \emph{value}, \emph{sep=':'}}{}
Same as prepend\_value but the value argument can be a list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{sep}) -- the environment variable to prepend

\item {} 
\textbf{str or list} (\emph{value}) -- the value(s) to prepend to key

\item {} 
\textbf{str} -- the separator string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{prepend\_value() (src.environment.Environ method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.Environ.prepend_value}\pysiglinewithargsret{\bfcode{prepend\_value}}{\emph{key}, \emph{value}, \emph{sep=':'}}{}
prepend value to key using sep
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{sep}) -- the environment variable to prepend

\item {} 
\textbf{str} -- the value to prepend to key

\item {} 
\textbf{str} -- the separator string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set() (src.environment.Environ method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.Environ.set}\pysiglinewithargsret{\bfcode{set}}{\emph{key}, \emph{value}}{}
Set the environment variable ``key'' to value ``value''
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{value}) -- the environment variable to set

\item {} 
\textbf{str} -- the value

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{FileEnvWriter (class in src.environment)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.FileEnvWriter}\pysiglinewithargsret{\strong{class }\code{src.environment.}\bfcode{FileEnvWriter}}{\emph{config}, \emph{logger}, \emph{out\_dir}, \emph{src\_root}, \emph{env\_info=None}}{}
Class to dump the environment to a file.
\index{write\_cfgForPy\_file() (src.environment.FileEnvWriter method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.FileEnvWriter.write_cfgForPy_file}\pysiglinewithargsret{\bfcode{write\_cfgForPy\_file}}{\emph{filename}, \emph{additional\_env=\{\}}, \emph{for\_package=None}, \emph{with\_commercial=True}}{}
Append to current opened aFile a cfgForPy 
environment (SALOME python launcher).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{for\_package}) -- the file path

\item {} 
\textbf{dict} (\emph{additional\_env}) -- a dictionary of additional variables 
to add to the environment

\item {} 
\textbf{str} -- If not None, produce a relative environment 
designed for a package.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_env\_file() (src.environment.FileEnvWriter method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.FileEnvWriter.write_env_file}\pysiglinewithargsret{\bfcode{write\_env\_file}}{\emph{filename}, \emph{forBuild}, \emph{shell}, \emph{for\_package=None}}{}
Create an environment file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{shell}) -- the file path

\item {} 
\textbf{bool} (\emph{forBuild}) -- if true, the build environment

\item {} 
\textbf{str} -- the type of file wanted (.sh, .bat)

\end{itemize}

\item[{Returns}] \leavevmode
The path to the generated file

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SalomeEnviron (class in src.environment)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron}\pysiglinewithargsret{\strong{class }\code{src.environment.}\bfcode{SalomeEnviron}}{\emph{cfg}, \emph{environ}, \emph{forBuild=False}, \emph{for\_package=None}, \emph{enable\_simple\_env\_script=True}}{}
Class to manage the environment of SALOME.
\index{add\_comment() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.add_comment}\pysiglinewithargsret{\bfcode{add\_comment}}{\emph{comment}}{}
Add a commentary to the out stream (in case of file generation)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{comment}) -- the commentary to add

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_line() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.add_line}\pysiglinewithargsret{\bfcode{add\_line}}{\emph{nb\_line}}{}
Add empty lines to the out stream (in case of file generation)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{int} (\emph{nb\_line}) -- the number of empty lines to add

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_warning() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.add_warning}\pysiglinewithargsret{\bfcode{add\_warning}}{\emph{warning}}{}
Add a warning to the out stream (in case of file generation)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{warning}) -- the warning to add

\end{description}\end{quote}

\end{fulllineitems}

\index{append() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.append}\pysiglinewithargsret{\bfcode{append}}{\emph{key}, \emph{value}, \emph{sep=':'}}{}
append value to key using sep
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{sep}) -- the environment variable to append

\item {} 
\textbf{str} -- the value to append to key

\item {} 
\textbf{str} -- the separator string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{dump() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.dump}\pysiglinewithargsret{\bfcode{dump}}{\emph{out}}{}
Write the environment to out
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{file} (\emph{out}) -- the stream where to write the environment

\end{description}\end{quote}

\end{fulllineitems}

\index{finish() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.finish}\pysiglinewithargsret{\bfcode{finish}}{\emph{required}}{}
Add a final instruction in the out file (in case of file generation)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{bool} (\emph{required}) -- Do nothing if required is False

\end{description}\end{quote}

\end{fulllineitems}

\index{get() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.get}\pysiglinewithargsret{\bfcode{get}}{\emph{key}}{}
Get the value of the environment variable ``key''
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{key}) -- the environment variable

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_names() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.get_names}\pysiglinewithargsret{\bfcode{get\_names}}{\emph{lProducts}}{}
Get the products name to add in SALOME\_MODULES environment variable
It is the name of the product, except in the case where the is a 
component name. And it has to be in SALOME\_MODULES variable only 
if the product has the property has\_salome\_hui = ``yes''
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{list} (\emph{lProducts}) -- List of products to potentially add

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_defined() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.is_defined}\pysiglinewithargsret{\bfcode{is\_defined}}{\emph{key}}{}
Check if the key exists in the environment
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{key}) -- the environment variable to check

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_cfg\_environment() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.load_cfg_environment}\pysiglinewithargsret{\bfcode{load\_cfg\_environment}}{\emph{cfg\_env}}{}
Loads environment defined in cfg\_env
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{cfg\_env}) -- A config containing an environment

\end{description}\end{quote}

\end{fulllineitems}

\index{prepend() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.prepend}\pysiglinewithargsret{\bfcode{prepend}}{\emph{key}, \emph{value}, \emph{sep=':'}}{}
prepend value to key using sep
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{sep}) -- the environment variable to prepend

\item {} 
\textbf{str} -- the value to prepend to key

\item {} 
\textbf{str} -- the separator string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_env\_script() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.run_env_script}\pysiglinewithargsret{\bfcode{run\_env\_script}}{\emph{product\_info}, \emph{logger=None}, \emph{native=False}}{}
Runs an environment script.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Config} (\emph{product\_info}) -- The product description

\item {} 
\textbf{Logger} (\emph{logger}) -- The logger instance to display messages

\item {} 
\textbf{Boolean} (\emph{native}) -- if True load set\_native\_env instead of set\_env

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_simple\_env\_script() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.run_simple_env_script}\pysiglinewithargsret{\bfcode{run\_simple\_env\_script}}{\emph{script\_path}, \emph{logger=None}}{}
Runs an environment script. Same as run\_env\_script, but with a 
script path as parameter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{script\_path}) -- a path to an environment script

\item {} 
\textbf{Logger} (\emph{logger}) -- The logger instance to display messages

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.set}\pysiglinewithargsret{\bfcode{set}}{\emph{key}, \emph{value}}{}
Set the environment variable ``key'' to value ``value''
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{value}) -- the environment variable to set

\item {} 
\textbf{str} -- the value

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_a\_product() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.set_a_product}\pysiglinewithargsret{\bfcode{set\_a\_product}}{\emph{product}, \emph{logger}}{}
Sets the environment of a product.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{product}) -- The product name

\item {} 
\textbf{Logger} (\emph{logger}) -- The logger instance to display messages

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_application\_env() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.set_application_env}\pysiglinewithargsret{\bfcode{set\_application\_env}}{\emph{logger}}{}
Sets the environment defined in the APPLICATION file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Logger} (\emph{logger}) -- The logger instance to display messages

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_cpp\_env() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.set_cpp_env}\pysiglinewithargsret{\bfcode{set\_cpp\_env}}{\emph{product\_info}}{}
Sets the generic environment for a SALOME cpp product.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The product description

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_full\_environ() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.set_full_environ}\pysiglinewithargsret{\bfcode{set\_full\_environ}}{\emph{logger}, \emph{env\_info}}{}
Sets the full environment for products 
specified in env\_info dictionary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Logger} (\emph{logger}) -- The logger instance to display messages

\item {} 
\textbf{list} (\emph{env\_info}) -- the list of products

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_products() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.set_products}\pysiglinewithargsret{\bfcode{set\_products}}{\emph{logger}, \emph{src\_root=None}}{}
Sets the environment for all the products.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Logger} (\emph{logger}) -- The logger instance to display messages

\item {} 
\textbf{src} (\emph{src\_root}) -- the application working directory

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_python\_libdirs() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.set_python_libdirs}\pysiglinewithargsret{\bfcode{set\_python\_libdirs}}{}{}
Set some generic variables for python library paths

\end{fulllineitems}

\index{set\_salome\_generic\_product\_env() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.set_salome_generic_product_env}\pysiglinewithargsret{\bfcode{set\_salome\_generic\_product\_env}}{\emph{pi}}{}
Sets the generic environment for a SALOME product.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{pi}) -- The product description

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_salome\_minimal\_product\_env() (src.environment.SalomeEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.SalomeEnviron.set_salome_minimal_product_env}\pysiglinewithargsret{\bfcode{set\_salome\_minimal\_product\_env}}{\emph{product\_info}, \emph{logger}}{}
Sets the minimal environment for a SALOME product.
xxx\_ROOT\_DIR and xxx\_SRC\_DIR
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Config} (\emph{product\_info}) -- The product description

\item {} 
\textbf{Logger} (\emph{logger}) -- The logger instance to display messages

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Shell (class in src.environment)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.Shell}\pysiglinewithargsret{\strong{class }\code{src.environment.}\bfcode{Shell}}{\emph{name}, \emph{extension}}{}
Definition of a Shell.

\end{fulllineitems}

\index{load\_environment() (in module src.environment)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.environment.load_environment}\pysiglinewithargsret{\code{src.environment.}\bfcode{load\_environment}}{\emph{config}, \emph{build}, \emph{logger}}{}
Loads the environment (used to run the tests, for example).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Config} (\emph{config}) -- the global config

\item {} 
\textbf{bool} (\emph{build}) -- build environement if True

\item {} 
\textbf{Logger} (\emph{logger}) -- The logger instance to display messages

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{\texttt{fileEnviron} Module}
\label{commands/apidoc/src:fileenviron-module}\label{commands/apidoc/src:module-src.fileEnviron}\index{src.fileEnviron (module)}\index{BashFileEnviron (class in src.fileEnviron)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.BashFileEnviron}\pysiglinewithargsret{\strong{class }\code{src.fileEnviron.}\bfcode{BashFileEnviron}}{\emph{output}, \emph{environ=None}}{}
Bases: {\hyperref[commands/apidoc/src:src.fileEnviron.FileEnviron]{\code{src.fileEnviron.FileEnviron}}}

Class for bash shell.
\index{command\_value() (src.fileEnviron.BashFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.BashFileEnviron.command_value}\pysiglinewithargsret{\bfcode{command\_value}}{\emph{key}, \emph{command}}{}
Get the value given by the system command ``command'' 
and put it in the environment variable key.
Has to be overwritten in the derived classes
This can be seen as a virtual method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{command}) -- the environment variable

\item {} 
\textbf{str} -- the command to execute

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{finish() (src.fileEnviron.BashFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.BashFileEnviron.finish}\pysiglinewithargsret{\bfcode{finish}}{\emph{required=True}}{}
Add a final instruction in the out file (in case of file generation)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{bool} (\emph{required}) -- Do nothing if required is False

\end{description}\end{quote}

\end{fulllineitems}

\index{set() (src.fileEnviron.BashFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.BashFileEnviron.set}\pysiglinewithargsret{\bfcode{set}}{\emph{key}, \emph{value}}{}
Set the environment variable ``key'' to value ``value''
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{value}) -- the environment variable to set

\item {} 
\textbf{str} -- the value

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{BatFileEnviron (class in src.fileEnviron)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.BatFileEnviron}\pysiglinewithargsret{\strong{class }\code{src.fileEnviron.}\bfcode{BatFileEnviron}}{\emph{output}, \emph{environ=None}}{}
Bases: {\hyperref[commands/apidoc/src:src.fileEnviron.FileEnviron]{\code{src.fileEnviron.FileEnviron}}}

for Windows batch shell.
\index{add\_comment() (src.fileEnviron.BatFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.BatFileEnviron.add_comment}\pysiglinewithargsret{\bfcode{add\_comment}}{\emph{comment}}{}
Add a comment in the shell file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{comment}) -- the comment to add

\end{description}\end{quote}

\end{fulllineitems}

\index{command\_value() (src.fileEnviron.BatFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.BatFileEnviron.command_value}\pysiglinewithargsret{\bfcode{command\_value}}{\emph{key}, \emph{command}}{}
Get the value given by the system command ``command'' 
and put it in the environment variable key.
Has to be overwritten in the derived classes
This can be seen as a virtual method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{command}) -- the environment variable

\item {} 
\textbf{str} -- the command to execute

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{finish() (src.fileEnviron.BatFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.BatFileEnviron.finish}\pysiglinewithargsret{\bfcode{finish}}{\emph{required=True}}{}
Add a final instruction in the out file (in case of file generation)
In the particular windows case, do nothing
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{bool} (\emph{required}) -- Do nothing if required is False

\end{description}\end{quote}

\end{fulllineitems}

\index{get() (src.fileEnviron.BatFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.BatFileEnviron.get}\pysiglinewithargsret{\bfcode{get}}{\emph{key}}{}
Get the value of the environment variable ``key''
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{key}) -- the environment variable

\end{description}\end{quote}

\end{fulllineitems}

\index{set() (src.fileEnviron.BatFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.BatFileEnviron.set}\pysiglinewithargsret{\bfcode{set}}{\emph{key}, \emph{value}}{}
Set the environment variable ``key'' to value ``value''
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{value}) -- the environment variable to set

\item {} 
\textbf{str} -- the value

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ContextFileEnviron (class in src.fileEnviron)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ContextFileEnviron}\pysiglinewithargsret{\strong{class }\code{src.fileEnviron.}\bfcode{ContextFileEnviron}}{\emph{output}, \emph{environ=None}}{}
Bases: {\hyperref[commands/apidoc/src:src.fileEnviron.FileEnviron]{\code{src.fileEnviron.FileEnviron}}}

Class for a salome context configuration file.
\index{add\_echo() (src.fileEnviron.ContextFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ContextFileEnviron.add_echo}\pysiglinewithargsret{\bfcode{add\_echo}}{\emph{text}}{}
Add a comment
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{text}) -- the comment to add

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_warning() (src.fileEnviron.ContextFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ContextFileEnviron.add_warning}\pysiglinewithargsret{\bfcode{add\_warning}}{\emph{warning}}{}
Add a warning
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{text}) -- the warning to add

\end{description}\end{quote}

\end{fulllineitems}

\index{append\_value() (src.fileEnviron.ContextFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ContextFileEnviron.append_value}\pysiglinewithargsret{\bfcode{append\_value}}{\emph{key}, \emph{value}, \emph{sep=':'}}{}
append value to key using sep
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{sep}) -- the environment variable to append

\item {} 
\textbf{str} -- the value to append to key

\item {} 
\textbf{str} -- the separator string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{command\_value() (src.fileEnviron.ContextFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ContextFileEnviron.command_value}\pysiglinewithargsret{\bfcode{command\_value}}{\emph{key}, \emph{command}}{}
Get the value given by the system command ``command'' 
and put it in the environment variable key.
Has to be overwritten in the derived classes
This can be seen as a virtual method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{command}) -- the environment variable

\item {} 
\textbf{str} -- the command to execute

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{finish() (src.fileEnviron.ContextFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ContextFileEnviron.finish}\pysiglinewithargsret{\bfcode{finish}}{\emph{required=True}}{}
Add a final instruction in the out file (in case of file generation)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{bool} (\emph{required}) -- Do nothing if required is False

\end{description}\end{quote}

\end{fulllineitems}

\index{get() (src.fileEnviron.ContextFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ContextFileEnviron.get}\pysiglinewithargsret{\bfcode{get}}{\emph{key}}{}
Get the value of the environment variable ``key''
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{key}) -- the environment variable

\end{description}\end{quote}

\end{fulllineitems}

\index{prepend\_value() (src.fileEnviron.ContextFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ContextFileEnviron.prepend_value}\pysiglinewithargsret{\bfcode{prepend\_value}}{\emph{key}, \emph{value}, \emph{sep=':'}}{}
prepend value to key using sep
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{sep}) -- the environment variable to prepend

\item {} 
\textbf{str} -- the value to prepend to key

\item {} 
\textbf{str} -- the separator string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set() (src.fileEnviron.ContextFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ContextFileEnviron.set}\pysiglinewithargsret{\bfcode{set}}{\emph{key}, \emph{value}}{}
Set the environment variable ``key'' to value ``value''
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{value}) -- the environment variable to set

\item {} 
\textbf{str} -- the value

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{FileEnviron (class in src.fileEnviron)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.FileEnviron}\pysiglinewithargsret{\strong{class }\code{src.fileEnviron.}\bfcode{FileEnviron}}{\emph{output}, \emph{environ=None}}{}
Bases: \code{object}

Base class for shell environment
\index{add\_comment() (src.fileEnviron.FileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.FileEnviron.add_comment}\pysiglinewithargsret{\bfcode{add\_comment}}{\emph{comment}}{}
Add a comment in the shell file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{comment}) -- the comment to add

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_echo() (src.fileEnviron.FileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.FileEnviron.add_echo}\pysiglinewithargsret{\bfcode{add\_echo}}{\emph{text}}{}
Add a ``echo'' in the shell file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{text}) -- the text to echo

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_line() (src.fileEnviron.FileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.FileEnviron.add_line}\pysiglinewithargsret{\bfcode{add\_line}}{\emph{number}}{}
Add some empty lines in the shell file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{int} (\emph{number}) -- the number of lines to add

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_warning() (src.fileEnviron.FileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.FileEnviron.add_warning}\pysiglinewithargsret{\bfcode{add\_warning}}{\emph{warning}}{}
Add a warning ``echo'' in the shell file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{warning}) -- the text to echo

\end{description}\end{quote}

\end{fulllineitems}

\index{append() (src.fileEnviron.FileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.FileEnviron.append}\pysiglinewithargsret{\bfcode{append}}{\emph{key}, \emph{value}, \emph{sep=':'}}{}
Same as append\_value but the value argument can be a list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{sep}) -- the environment variable to append

\item {} 
\textbf{str or list} (\emph{value}) -- the value(s) to append to key

\item {} 
\textbf{str} -- the separator string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{append\_value() (src.fileEnviron.FileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.FileEnviron.append_value}\pysiglinewithargsret{\bfcode{append\_value}}{\emph{key}, \emph{value}, \emph{sep=':'}}{}
append value to key using sep
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{sep}) -- the environment variable to append

\item {} 
\textbf{str} -- the value to append to key

\item {} 
\textbf{str} -- the separator string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{command\_value() (src.fileEnviron.FileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.FileEnviron.command_value}\pysiglinewithargsret{\bfcode{command\_value}}{\emph{key}, \emph{command}}{}
Get the value given by the system command ``command'' 
and put it in the environment variable key.
Has to be overwritten in the derived classes
This can be seen as a virtual method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{command}) -- the environment variable

\item {} 
\textbf{str} -- the command to execute

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{finish() (src.fileEnviron.FileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.FileEnviron.finish}\pysiglinewithargsret{\bfcode{finish}}{\emph{required=True}}{}
Add a final instruction in the out file (in case of file generation)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{bool} (\emph{required}) -- Do nothing if required is False

\end{description}\end{quote}

\end{fulllineitems}

\index{get() (src.fileEnviron.FileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.FileEnviron.get}\pysiglinewithargsret{\bfcode{get}}{\emph{key}}{}
Get the value of the environment variable ``key''
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{key}) -- the environment variable

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_defined() (src.fileEnviron.FileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.FileEnviron.is_defined}\pysiglinewithargsret{\bfcode{is\_defined}}{\emph{key}}{}
Check if the key exists in the environment
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{key}) -- the environment variable to check

\end{description}\end{quote}

\end{fulllineitems}

\index{prepend() (src.fileEnviron.FileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.FileEnviron.prepend}\pysiglinewithargsret{\bfcode{prepend}}{\emph{key}, \emph{value}, \emph{sep=':'}}{}
Same as prepend\_value but the value argument can be a list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{sep}) -- the environment variable to prepend

\item {} 
\textbf{str or list} (\emph{value}) -- the value(s) to prepend to key

\item {} 
\textbf{str} -- the separator string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{prepend\_value() (src.fileEnviron.FileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.FileEnviron.prepend_value}\pysiglinewithargsret{\bfcode{prepend\_value}}{\emph{key}, \emph{value}, \emph{sep=':'}}{}
prepend value to key using sep
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{sep}) -- the environment variable to prepend

\item {} 
\textbf{str} -- the value to prepend to key

\item {} 
\textbf{str} -- the separator string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set() (src.fileEnviron.FileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.FileEnviron.set}\pysiglinewithargsret{\bfcode{set}}{\emph{key}, \emph{value}}{}
Set the environment variable `key' to value `value'
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{value}) -- the environment variable to set

\item {} 
\textbf{str} -- the value

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{LauncherFileEnviron (class in src.fileEnviron)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.LauncherFileEnviron}\pysiglinewithargsret{\strong{class }\code{src.fileEnviron.}\bfcode{LauncherFileEnviron}}{\emph{output}, \emph{environ=None}}{}
Class to generate a launcher file script 
(in python syntax) SalomeContext API
\index{add() (src.fileEnviron.LauncherFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.LauncherFileEnviron.add}\pysiglinewithargsret{\bfcode{add}}{\emph{key}, \emph{value}}{}
prepend value to key using sep
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{value}) -- the environment variable to prepend

\item {} 
\textbf{str} -- the value to prepend to key

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_comment() (src.fileEnviron.LauncherFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.LauncherFileEnviron.add_comment}\pysiglinewithargsret{\bfcode{add\_comment}}{\emph{comment}}{}
\end{fulllineitems}

\index{add\_echo() (src.fileEnviron.LauncherFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.LauncherFileEnviron.add_echo}\pysiglinewithargsret{\bfcode{add\_echo}}{\emph{text}}{}
Add a comment
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{text}) -- the comment to add

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_line() (src.fileEnviron.LauncherFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.LauncherFileEnviron.add_line}\pysiglinewithargsret{\bfcode{add\_line}}{\emph{number}}{}
Add some empty lines in the launcher file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{int} (\emph{number}) -- the number of lines to add

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_warning() (src.fileEnviron.LauncherFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.LauncherFileEnviron.add_warning}\pysiglinewithargsret{\bfcode{add\_warning}}{\emph{warning}}{}
Add a warning
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{text}) -- the warning to add

\end{description}\end{quote}

\end{fulllineitems}

\index{append() (src.fileEnviron.LauncherFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.LauncherFileEnviron.append}\pysiglinewithargsret{\bfcode{append}}{\emph{key}, \emph{value}, \emph{sep=':'}}{}
Same as append\_value but the value argument can be a list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{sep}) -- the environment variable to append

\item {} 
\textbf{str or list} (\emph{value}) -- the value(s) to append to key

\item {} 
\textbf{str} -- the separator string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{append\_value() (src.fileEnviron.LauncherFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.LauncherFileEnviron.append_value}\pysiglinewithargsret{\bfcode{append\_value}}{\emph{key}, \emph{value}, \emph{sep=':'}}{}
append value to key using sep
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{sep}) -- the environment variable to append

\item {} 
\textbf{str} -- the value to append to key

\item {} 
\textbf{str} -- the separator string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{change\_to\_launcher() (src.fileEnviron.LauncherFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.LauncherFileEnviron.change_to_launcher}\pysiglinewithargsret{\bfcode{change\_to\_launcher}}{\emph{value}}{}
\end{fulllineitems}

\index{command\_value() (src.fileEnviron.LauncherFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.LauncherFileEnviron.command_value}\pysiglinewithargsret{\bfcode{command\_value}}{\emph{key}, \emph{command}}{}
Get the value given by the system command ``command'' 
and put it in the environment variable key.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{command}) -- the environment variable

\item {} 
\textbf{str} -- the command to execute

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{finish() (src.fileEnviron.LauncherFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.LauncherFileEnviron.finish}\pysiglinewithargsret{\bfcode{finish}}{\emph{required=True}}{}
Add a final instruction in the out file (in case of file generation)
In the particular launcher case, do nothing
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{bool} (\emph{required}) -- Do nothing if required is False

\end{description}\end{quote}

\end{fulllineitems}

\index{get() (src.fileEnviron.LauncherFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.LauncherFileEnviron.get}\pysiglinewithargsret{\bfcode{get}}{\emph{key}}{}
Get the value of the environment variable ``key''
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{key}) -- the environment variable

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_defined() (src.fileEnviron.LauncherFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.LauncherFileEnviron.is_defined}\pysiglinewithargsret{\bfcode{is\_defined}}{\emph{key}}{}
Check if the key exists in the environment
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{key}) -- the environment variable to check

\end{description}\end{quote}

\end{fulllineitems}

\index{prepend() (src.fileEnviron.LauncherFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.LauncherFileEnviron.prepend}\pysiglinewithargsret{\bfcode{prepend}}{\emph{key}, \emph{value}, \emph{sep=':'}}{}
Same as prepend\_value but the value argument can be a list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{sep}) -- the environment variable to prepend

\item {} 
\textbf{str or list} (\emph{value}) -- the value(s) to prepend to key

\item {} 
\textbf{str} -- the separator string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{prepend\_value() (src.fileEnviron.LauncherFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.LauncherFileEnviron.prepend_value}\pysiglinewithargsret{\bfcode{prepend\_value}}{\emph{key}, \emph{value}, \emph{sep=':'}}{}
prepend value to key using sep
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{sep}) -- the environment variable to prepend

\item {} 
\textbf{str} -- the value to prepend to key

\item {} 
\textbf{str} -- the separator string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set() (src.fileEnviron.LauncherFileEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.LauncherFileEnviron.set}\pysiglinewithargsret{\bfcode{set}}{\emph{key}, \emph{value}}{}
Set the environment variable ``key'' to value ``value''
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{value}) -- the environment variable to set

\item {} 
\textbf{str} -- the value

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ScreenEnviron (class in src.fileEnviron)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ScreenEnviron}\pysiglinewithargsret{\strong{class }\code{src.fileEnviron.}\bfcode{ScreenEnviron}}{\emph{output}, \emph{environ=None}}{}
Bases: {\hyperref[commands/apidoc/src:src.fileEnviron.FileEnviron]{\code{src.fileEnviron.FileEnviron}}}
\index{add\_comment() (src.fileEnviron.ScreenEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ScreenEnviron.add_comment}\pysiglinewithargsret{\bfcode{add\_comment}}{\emph{comment}}{}
\end{fulllineitems}

\index{add\_echo() (src.fileEnviron.ScreenEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ScreenEnviron.add_echo}\pysiglinewithargsret{\bfcode{add\_echo}}{\emph{text}}{}
\end{fulllineitems}

\index{add\_line() (src.fileEnviron.ScreenEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ScreenEnviron.add_line}\pysiglinewithargsret{\bfcode{add\_line}}{\emph{number}}{}
\end{fulllineitems}

\index{add\_warning() (src.fileEnviron.ScreenEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ScreenEnviron.add_warning}\pysiglinewithargsret{\bfcode{add\_warning}}{\emph{warning}}{}
\end{fulllineitems}

\index{append() (src.fileEnviron.ScreenEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ScreenEnviron.append}\pysiglinewithargsret{\bfcode{append}}{\emph{name}, \emph{value}, \emph{sep=':'}}{}
\end{fulllineitems}

\index{command\_value() (src.fileEnviron.ScreenEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ScreenEnviron.command_value}\pysiglinewithargsret{\bfcode{command\_value}}{\emph{key}, \emph{command}}{}
\end{fulllineitems}

\index{get() (src.fileEnviron.ScreenEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ScreenEnviron.get}\pysiglinewithargsret{\bfcode{get}}{\emph{name}}{}
\end{fulllineitems}

\index{is\_defined() (src.fileEnviron.ScreenEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ScreenEnviron.is_defined}\pysiglinewithargsret{\bfcode{is\_defined}}{\emph{name}}{}
\end{fulllineitems}

\index{prepend() (src.fileEnviron.ScreenEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ScreenEnviron.prepend}\pysiglinewithargsret{\bfcode{prepend}}{\emph{name}, \emph{value}, \emph{sep=':'}}{}
\end{fulllineitems}

\index{run\_env\_script() (src.fileEnviron.ScreenEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ScreenEnviron.run_env_script}\pysiglinewithargsret{\bfcode{run\_env\_script}}{\emph{module}, \emph{script}}{}
\end{fulllineitems}

\index{set() (src.fileEnviron.ScreenEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ScreenEnviron.set}\pysiglinewithargsret{\bfcode{set}}{\emph{name}, \emph{value}}{}
\end{fulllineitems}

\index{write() (src.fileEnviron.ScreenEnviron method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.ScreenEnviron.write}\pysiglinewithargsret{\bfcode{write}}{\emph{command}, \emph{name}, \emph{value}, \emph{sign='='}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{get\_file\_environ() (in module src.fileEnviron)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.get_file_environ}\pysiglinewithargsret{\code{src.fileEnviron.}\bfcode{get\_file\_environ}}{\emph{output}, \emph{shell}, \emph{environ=None}}{}
Instantiate correct FileEnvironment sub-class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{file} (\emph{output}) -- the output file stream.

\item {} 
\textbf{str} (\emph{shell}) -- the type of shell syntax to use.

\item {} 
\textbf{dict} (\emph{environ}) -- a potential additional environment.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{special\_path\_separator() (in module src.fileEnviron)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fileEnviron.special_path_separator}\pysiglinewithargsret{\code{src.fileEnviron.}\bfcode{special\_path\_separator}}{\emph{name}}{}
TCLLIBPATH, TKLIBPATH, PV\_PLUGIN\_PATH environments variables need
some exotic path separator.
This function gives the separator regarding the name of the variable
to append or prepend.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{name}) -- The name of the variable to find the separator

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{\texttt{fork} Module}
\label{commands/apidoc/src:fork-module}\label{commands/apidoc/src:module-src.fork}\index{src.fork (module)}\index{batch() (in module src.fork)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fork.batch}\pysiglinewithargsret{\code{src.fork.}\bfcode{batch}}{\emph{cmd}, \emph{logger}, \emph{cwd}, \emph{args=}\optional{}, \emph{log=None}, \emph{delai=20}, \emph{sommeil=1}}{}
\end{fulllineitems}

\index{batch\_salome() (in module src.fork)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fork.batch_salome}\pysiglinewithargsret{\code{src.fork.}\bfcode{batch\_salome}}{\emph{cmd}, \emph{logger}, \emph{cwd}, \emph{args}, \emph{getTmpDir}, \emph{pendant='SALOME\_Session\_Server'}, \emph{fin='killSalome.py'}, \emph{log=None}, \emph{delai=20}, \emph{sommeil=1}, \emph{delaiapp=0}}{}
\end{fulllineitems}

\index{launch\_command() (in module src.fork)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fork.launch_command}\pysiglinewithargsret{\code{src.fork.}\bfcode{launch\_command}}{\emph{cmd}, \emph{logger}, \emph{cwd}, \emph{args=}\optional{}, \emph{log=None}}{}
\end{fulllineitems}

\index{show\_progress() (in module src.fork)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fork.show_progress}\pysiglinewithargsret{\code{src.fork.}\bfcode{show\_progress}}{\emph{logger}, \emph{top}, \emph{delai}, \emph{ss='`}}{}
shortcut function to display the progression
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Logger} (\emph{logger}) -- The logging instance

\item {} 
\textbf{int} (\emph{delai}) -- the number to display

\item {} 
\textbf{int} -- the number max

\item {} 
\textbf{str} (\emph{ss}) -- the string to display

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_back() (in module src.fork)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.fork.write_back}\pysiglinewithargsret{\code{src.fork.}\bfcode{write\_back}}{\emph{logger}, \emph{message}, \emph{level}}{}
shortcut function to write at the begin of the line
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Logger} (\emph{logger}) -- The logging instance

\item {} 
\textbf{str} (\emph{message}) -- the text to display

\item {} 
\textbf{int} (\emph{level}) -- the level of verbosity

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{\texttt{logger} Module}
\label{commands/apidoc/src:logger-module}\label{commands/apidoc/src:module-src.logger}\index{src.logger (module)}
Implements the classes and method relative to the logging
\index{Logger (class in src.logger)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.logger.Logger}\pysiglinewithargsret{\strong{class }\code{src.logger.}\bfcode{Logger}}{\emph{config}, \emph{silent\_sysstd=False}, \emph{all\_in\_terminal=False}, \emph{micro\_command=False}}{}
Bases: \code{object}

Class to handle log mechanism.
\index{add\_link() (src.logger.Logger method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.logger.Logger.add_link}\pysiglinewithargsret{\bfcode{add\_link}}{\emph{log\_file\_name}, \emph{command\_name}, \emph{command\_res}, \emph{full\_launched\_command}}{}
Add a link to another log file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{command\_res}) -- The file name of the link.

\item {} 
\textbf{str} -- The name of the command linked.

\item {} 
\textbf{str} -- The result of the command linked. ``0'' or ``1''

\end{itemize}

\item[{Parma full\_launched\_command str}] \leavevmode
The full lanch command 
(``sat command ...'')

\end{description}\end{quote}

\end{fulllineitems}

\index{end\_write() (src.logger.Logger method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.logger.Logger.end_write}\pysiglinewithargsret{\bfcode{end\_write}}{\emph{attribute}}{}
Called just after command end: Put all fields 
corresponding to the command end context (time).
Write the log xml file on the hard drive.
And display the command to launch to get the log
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{dict} (\emph{attribute}) -- the attribute to add to the node ``Site''.

\end{description}\end{quote}

\end{fulllineitems}

\index{error() (src.logger.Logger method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.logger.Logger.error}\pysiglinewithargsret{\bfcode{error}}{\emph{message}}{}
Print an error.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{message}) -- The message to print.

\end{description}\end{quote}

\end{fulllineitems}

\index{flush() (src.logger.Logger method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.logger.Logger.flush}\pysiglinewithargsret{\bfcode{flush}}{}{}
Flush terminal

\end{fulllineitems}

\index{put\_initial\_xml\_fields() (src.logger.Logger method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.logger.Logger.put_initial_xml_fields}\pysiglinewithargsret{\bfcode{put\_initial\_xml\_fields}}{}{}
Called at class initialization: Put all fields 
corresponding to the command context (user, time, ...)

\end{fulllineitems}

\index{write() (src.logger.Logger method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.logger.Logger.write}\pysiglinewithargsret{\bfcode{write}}{\emph{message}, \emph{level=None}, \emph{screenOnly=False}}{}
function used in the commands 
to print in the terminal and the log file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{message}) -- The message to print.

\item {} 
\textbf{int} (\emph{level}) -- The output level corresponding 
to the message 0 \textless{} level \textless{} 6.

\item {} 
\textbf{boolean} (\emph{screenOnly}) -- if True, do not write in log file.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{date\_to\_datetime() (in module src.logger)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.logger.date_to_datetime}\pysiglinewithargsret{\code{src.logger.}\bfcode{date\_to\_datetime}}{\emph{date}}{}
From a string date in format YYYYMMDD\_HHMMSS
returns list year, mon, day, hour, minutes, seconds
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{date}) -- The date in format YYYYMMDD\_HHMMSS

\item[{Returns}] \leavevmode
the same date and time in separate variables.

\item[{Return type}] \leavevmode
(str,str,str,str,str,str)

\end{description}\end{quote}

\end{fulllineitems}

\index{list\_log\_file() (in module src.logger)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.logger.list_log_file}\pysiglinewithargsret{\code{src.logger.}\bfcode{list\_log\_file}}{\emph{dirPath}, \emph{expression}}{}
Find all files corresponding to expression in dirPath
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{expression}) -- the directory where to search the files

\item {} 
\textbf{str} -- the regular expression of files to find

\end{itemize}

\item[{Returns}] \leavevmode
the list of files path and informations about it

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{show\_command\_log() (in module src.logger)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.logger.show_command_log}\pysiglinewithargsret{\code{src.logger.}\bfcode{show\_command\_log}}{\emph{logFilePath}, \emph{cmd}, \emph{application}, \emph{notShownCommands}}{}
Used in updateHatXml. 
Determine if the log xml file logFilePath 
has to be shown or not in the hat log.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{application}) -- the path to the command xml log file

\item {} 
\textbf{str} -- the command of the log file

\item {} 
\textbf{str} -- the application passed as parameter 
to the salomeTools command

\item {} 
\textbf{list} (\emph{notShownCommands}) -- the list of commands 
that are not shown by default

\end{itemize}

\item[{Returns}] \leavevmode
True if cmd is not in notShownCommands and the application 
in the log file corresponds to application

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{timedelta\_total\_seconds() (in module src.logger)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.logger.timedelta_total_seconds}\pysiglinewithargsret{\code{src.logger.}\bfcode{timedelta\_total\_seconds}}{\emph{timedelta}}{}
Replace total\_seconds from datetime module 
in order to be compatible with old python versions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{datetime.timedelta} (\emph{timedelta}) -- The delta between two dates

\item[{Returns}] \leavevmode
The number of seconds corresponding to timedelta.

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_hat\_xml() (in module src.logger)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.logger.update_hat_xml}\pysiglinewithargsret{\code{src.logger.}\bfcode{update\_hat\_xml}}{\emph{logDir}, \emph{application=None}, \emph{notShownCommands=}\optional{}}{}
Create the xml file in logDir that contain all the xml file 
and have a name like YYYYMMDD\_HHMMSS\_namecmd.xml
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{application}) -- the directory to parse

\item {} 
\textbf{str} -- the name of the application if there is any

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{\texttt{options} Module}
\label{commands/apidoc/src:module-src.options}\label{commands/apidoc/src:options-module}\index{src.options (module)}
The Options class that manages the access to all options passed as 
parameters in salomeTools command lines
\index{OptResult (class in src.options)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.options.OptResult}\pysigline{\strong{class }\code{src.options.}\bfcode{OptResult}}
Bases: \code{object}

An instance of this class will be the object manipulated
in code of all salomeTools commands
The aim of this class is to have an elegant syntax 
to manipulate the options. 
ex: 
print(options.level)
5

\end{fulllineitems}

\index{Options (class in src.options)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.options.Options}\pysigline{\strong{class }\code{src.options.}\bfcode{Options}}
Class to manage all salomeTools options
\index{add\_option() (src.options.Options method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.options.Options.add_option}\pysiglinewithargsret{\bfcode{add\_option}}{\emph{shortName}, \emph{longName}, \emph{optionType}, \emph{destName}, \emph{helpString='`}, \emph{default=None}}{}
Method to add an option to a command. It gets all attributes
of an option and append it in the options field
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{helpString}) -- The short name of the option
(ex ``l'' for level option).

\item {} 
\textbf{str} -- The long name of the option 
(ex ``level'' for level option).

\item {} 
\textbf{str} -- The type of the option (ex ``int'').

\item {} 
\textbf{str} -- The name that will be used in the code.

\item {} 
\textbf{str} -- The text to display 
when user ask for help on a command.

\end{itemize}

\item[{Returns}] \leavevmode
Nothing.

\item[{Return type}] \leavevmode
NA

\end{description}\end{quote}

\end{fulllineitems}

\index{parse\_args() (src.options.Options method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.options.Options.parse_args}\pysiglinewithargsret{\bfcode{parse\_args}}{\emph{argList=None}}{}
Method that instantiates the class OptResult 
that gives access to all options in the code
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{list} (\emph{argList}) -- the raw list of arguments that were passed

\item[{Returns}] \leavevmode
optResult, args : optResult is the option instance 
to manipulate in the code. args 
is the full raw list of passed options

\item[{Return type}] \leavevmode
(class `common.options.OptResult',list)

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_help() (src.options.Options method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.options.Options.print_help}\pysiglinewithargsret{\bfcode{print\_help}}{}{}
Method that display all options stored in self.options and there help
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Nothing.

\item[{Return type}] \leavevmode
NA

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{\texttt{printcolors} Module}
\label{commands/apidoc/src:printcolors-module}\label{commands/apidoc/src:module-src.printcolors}\index{src.printcolors (module)}
In this file is stored the mechanism that manage color prints in the terminal
\index{cleancolor() (in module src.printcolors)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.printcolors.cleancolor}\pysiglinewithargsret{\code{src.printcolors.}\bfcode{cleancolor}}{\emph{message}}{}
remove color from a colored text.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{message}) -- The text to be cleaned.

\item[{Returns}] \leavevmode
The cleaned text.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_color\_map() (in module src.printcolors)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.printcolors.print_color_map}\pysiglinewithargsret{\code{src.printcolors.}\bfcode{print\_color\_map}}{}{}
This method prints the color map

\end{fulllineitems}

\index{print\_color\_range() (in module src.printcolors)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.printcolors.print_color_range}\pysiglinewithargsret{\code{src.printcolors.}\bfcode{print\_color\_range}}{\emph{start}, \emph{end}}{}
print possible range values for colors
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{int} (\emph{end}) -- The smaller value.

\item {} 
\textbf{int} -- The bigger value.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_value() (in module src.printcolors)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.printcolors.print_value}\pysiglinewithargsret{\code{src.printcolors.}\bfcode{print\_value}}{\emph{logger}, \emph{label}, \emph{value}, \emph{level=1}, \emph{suffix='`}}{}
shortcut method to print a label and a value with the info color
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{class logger} (\emph{logger}) -- the logger instance.

\item {} 
\textbf{int} (\emph{level}) -- the label to print.

\item {} 
\textbf{str} (\emph{suffix}) -- the value to print.

\item {} 
\textbf{int} -- the level of verboseness.

\item {} 
\textbf{str} -- the suffix to add at the end.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{printc() (in module src.printcolors)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.printcolors.printc}\pysiglinewithargsret{\code{src.printcolors.}\bfcode{printc}}{\emph{txt}, \emph{code='`}}{}
print a text with colors
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{code}) -- The text to be printed.

\item {} 
\textbf{str} -- The color to use.

\end{itemize}

\item[{Returns}] \leavevmode
The colored text.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{printcError() (in module src.printcolors)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.printcolors.printcError}\pysiglinewithargsret{\code{src.printcolors.}\bfcode{printcError}}{\emph{txt}}{}
print a text error color
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{txt}) -- The text to be printed.

\item[{Returns}] \leavevmode
The colored text.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{printcHeader() (in module src.printcolors)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.printcolors.printcHeader}\pysiglinewithargsret{\code{src.printcolors.}\bfcode{printcHeader}}{\emph{txt}}{}
print a text header color
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{txt}) -- The text to be printed.

\item[{Returns}] \leavevmode
The colored text.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{printcHighlight() (in module src.printcolors)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.printcolors.printcHighlight}\pysiglinewithargsret{\code{src.printcolors.}\bfcode{printcHighlight}}{\emph{txt}}{}
print a text highlight color
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{txt}) -- The text to be printed.

\item[{Returns}] \leavevmode
The colored text.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{printcInfo() (in module src.printcolors)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.printcolors.printcInfo}\pysiglinewithargsret{\code{src.printcolors.}\bfcode{printcInfo}}{\emph{txt}}{}
print a text info color
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{txt}) -- The text to be printed.

\item[{Returns}] \leavevmode
The colored text.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{printcLabel() (in module src.printcolors)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.printcolors.printcLabel}\pysiglinewithargsret{\code{src.printcolors.}\bfcode{printcLabel}}{\emph{txt}}{}
print a text label color
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{txt}) -- The text to be printed.

\item[{Returns}] \leavevmode
The colored text.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{printcSuccess() (in module src.printcolors)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.printcolors.printcSuccess}\pysiglinewithargsret{\code{src.printcolors.}\bfcode{printcSuccess}}{\emph{txt}}{}
print a text success color
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{txt}) -- The text to be printed.

\item[{Returns}] \leavevmode
The colored text.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{printcWarning() (in module src.printcolors)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.printcolors.printcWarning}\pysiglinewithargsret{\code{src.printcolors.}\bfcode{printcWarning}}{\emph{txt}}{}
print a text warning color
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{txt}) -- The text to be printed.

\item[{Returns}] \leavevmode
The colored text.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{\texttt{product} Module}
\label{commands/apidoc/src:module-src.product}\label{commands/apidoc/src:product-module}\index{src.product (module)}
In this file are implemented the methods 
relative to the product notion of salomeTools
\index{check\_config\_exists() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.check_config_exists}\pysiglinewithargsret{\code{src.product.}\bfcode{check\_config\_exists}}{\emph{config}, \emph{prod\_dir}, \emph{prod\_info}}{}
Verify that the installation directory of a product in a base exists
Check all the config-\textless{}i\textgreater{} directory and verify the sat-config.pyconf file
that is in it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Config} (\emph{product\_info}) -- The global configuration

\item {} 
\textbf{str} (\emph{prod\_dir}) -- The product installation directory path 
(without config-\textless{}i\textgreater{})

\item {} 
\textbf{Config} -- The configuration specific to 
the product

\end{itemize}

\item[{Returns}] \leavevmode
True or false is the installation is found or not 
and if it is found, the path of the found installation

\item[{Return type}] \leavevmode
(boolean, str)

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_installation() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.check_installation}\pysiglinewithargsret{\code{src.product.}\bfcode{check\_installation}}{\emph{product\_info}}{}
Verify if a product is well installed. Checks install directory presence
and some additional files if it is defined in the config
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if it is well installed

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_source() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.check_source}\pysiglinewithargsret{\code{src.product.}\bfcode{check\_source}}{\emph{product\_info}}{}
Verify if a sources of product is preset. Checks source directory presence
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if it is well installed

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_base\_install\_dir() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.get_base_install_dir}\pysiglinewithargsret{\code{src.product.}\bfcode{get\_base\_install\_dir}}{\emph{config}, \emph{prod\_info}, \emph{version}}{}
Compute the installation directory of a product in base
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Config} (\emph{product\_info}) -- The global configuration

\item {} 
\textbf{Config} -- The configuration specific to 
the product

\item {} 
\textbf{str} (\emph{version}) -- The version of the product

\end{itemize}

\item[{Returns}] \leavevmode
The path of the product installation

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_install\_dir() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.get_install_dir}\pysiglinewithargsret{\code{src.product.}\bfcode{get\_install\_dir}}{\emph{config}, \emph{base}, \emph{version}, \emph{prod\_info}}{}
Compute the installation directory of a given product
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Config} (\emph{product\_info}) -- The global configuration

\item {} 
\textbf{str} (\emph{version}) -- This corresponds to the value given by user in its 
application.pyconf for the specific product. If ``yes'', the
user wants the product to be in base. If ``no'', he wants the
product to be in the application workdir

\item {} 
\textbf{str} -- The version of the product

\item {} 
\textbf{Config} -- The configuration specific to 
the product

\end{itemize}

\item[{Returns}] \leavevmode
The path of the product installation

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_product\_components() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.get_product_components}\pysiglinewithargsret{\code{src.product.}\bfcode{get\_product\_components}}{\emph{product\_info}}{}
Get the component list to generate with the product
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
The list of names of the components

\item[{Return type}] \leavevmode
List

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_product\_config() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.get_product_config}\pysiglinewithargsret{\code{src.product.}\bfcode{get\_product\_config}}{\emph{config}, \emph{product\_name}, \emph{with\_install\_dir=True}}{}
Get the specific configuration of a product from the global configuration
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Config} (\emph{config}) -- The global configuration

\item {} 
\textbf{str} (\emph{product\_name}) -- The name of the product

\item {} 
\textbf{boolean} (\emph{with\_install\_dir}) -- If false, do not provide an install 
directory (at false only for internal use 
of the function check\_config\_exists)

\end{itemize}

\item[{Returns}] \leavevmode
the specific configuration of the product

\item[{Return type}] \leavevmode
Config

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_product\_dependencies() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.get_product_dependencies}\pysiglinewithargsret{\code{src.product.}\bfcode{get\_product\_dependencies}}{\emph{config}, \emph{product\_info}}{}
Get recursively the list of products that are 
in the product\_info dependencies
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Config} (\emph{product\_info}) -- The global configuration

\item {} 
\textbf{Config} -- The configuration specific to 
the product

\end{itemize}

\item[{Returns}] \leavevmode
the list of products in dependence

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_product\_section() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.get_product_section}\pysiglinewithargsret{\code{src.product.}\bfcode{get\_product\_section}}{\emph{config}, \emph{product\_name}, \emph{version}, \emph{section=None}}{}
Get the product description from the configuration
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Config} (\emph{config}) -- The global configuration

\item {} 
\textbf{str} (\emph{section}) -- The product name

\item {} 
\textbf{str} -- The version of the product

\item {} 
\textbf{str} -- The searched section (if not None, the section is 
explicitly given

\end{itemize}

\item[{Returns}] \leavevmode
The product description

\item[{Return type}] \leavevmode
Config

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_products\_infos() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.get_products_infos}\pysiglinewithargsret{\code{src.product.}\bfcode{get\_products\_infos}}{\emph{lproducts}, \emph{config}}{}
Get the specific configuration of a list of products
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{List} (\emph{lproducts}) -- The list of product names

\item {} 
\textbf{Config} (\emph{config}) -- The global configuration

\end{itemize}

\item[{Returns}] \leavevmode
the list of tuples 
(product name, specific configuration of the product)

\item[{Return type}] \leavevmode
{[}(str, Config){]}

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_compiles() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_compiles}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_compiles}}{\emph{product\_info}}{}
Know if a product compiles or not 
(some products do not have a compilation procedure)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product compiles, else False

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_has\_env\_script() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_has_env_script}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_has\_env\_script}}{\emph{product\_info}}{}
Know if a product has an environment script
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product it has an environment script, else False

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_has\_logo() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_has_logo}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_has\_logo}}{\emph{product\_info}}{}
Know if a product has a logo (YACSGEN generate)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
The path of the logo if the product has a logo, else False

\item[{Return type}] \leavevmode
Str

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_has\_patches() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_has_patches}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_has\_patches}}{\emph{product\_info}}{}
Know if a product has one or more patches
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product has one or more patches

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_has\_salome\_gui() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_has_salome_gui}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_has\_salome\_gui}}{\emph{product\_info}}{}
Know if a product has a SALOME gui
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product has a SALOME gui, else False

\item[{Return type}] \leavevmode
Boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_has\_script() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_has_script}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_has\_script}}{\emph{product\_info}}{}
Know if a product has a compilation script
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product it has a compilation script, else False

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_is\_autotools() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_is_autotools}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_is\_autotools}}{\emph{product\_info}}{}
Know if a product is compiled using the autotools
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product is autotools, else False

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_is\_cmake() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_is_cmake}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_is\_cmake}}{\emph{product\_info}}{}
Know if a product is compiled using the cmake
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product is cmake, else False

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_is\_cpp() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_is_cpp}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_is\_cpp}}{\emph{product\_info}}{}
Know if a product is cpp
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product is a cpp, else False

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_is\_debug() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_is_debug}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_is\_debug}}{\emph{product\_info}}{}
Know if a product is in debug mode
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product is in debug mode, else False

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_is\_dev() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_is_dev}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_is\_dev}}{\emph{product\_info}}{}
Know if a product is in dev mode
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product is in dev mode, else False

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_is\_fixed() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_is_fixed}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_is\_fixed}}{\emph{product\_info}}{}
Know if a product is fixed
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product is fixed, else False

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_is\_generated() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_is_generated}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_is\_generated}}{\emph{product\_info}}{}
Know if a product is generated (YACSGEN)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product is generated

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_is\_mpi() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_is_mpi}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_is\_mpi}}{\emph{product\_info}}{}
Know if a product has openmpi in its dependencies
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product has openmpi inits dependencies

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_is\_native() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_is_native}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_is\_native}}{\emph{product\_info}}{}
Know if a product is native
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product is native, else False

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_is\_salome() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_is_salome}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_is\_salome}}{\emph{product\_info}}{}
Know if a product is a SALOME module
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product is a SALOME module, else False

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_is\_sample() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_is_sample}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_is\_sample}}{\emph{product\_info}}{}
Know if a product has the sample type
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product has the sample type, else False

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_is\_smesh\_plugin() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_is_smesh_plugin}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_is\_smesh\_plugin}}{\emph{product\_info}}{}
Know if a product is a SMESH plugin
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product is a SMESH plugin, else False

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{product\_is\_vcs() (in module src.product)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.product.product_is_vcs}\pysiglinewithargsret{\code{src.product.}\bfcode{product\_is\_vcs}}{\emph{product\_info}}{}
Know if a product is download using git, svn or cvs (not archive)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Config} (\emph{product\_info}) -- The configuration specific to 
the product

\item[{Returns}] \leavevmode
True if the product is vcs, else False

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{\texttt{pyconf} Module}
\label{commands/apidoc/src:pyconf-module}\label{commands/apidoc/src:module-src.pyconf}\index{src.pyconf (module)}
This is a configuration module for Python.

This module should work under Python versions \textgreater{}= 2.2, and cannot be used with
earlier versions since it uses new-style classes.

Development and testing has only been carried out (so far) on Python 2.3.4 and
Python 2.4.2. See the test module (test\_config.py) included in the
U\{distribution\textless{}\href{http://www.red-dove.com/python\_config}{http://www.red-dove.com/python\_config}.html\textbar{}\_blank\textgreater{}\} (follow the
download link).

A simple example - with the example configuration file:

\begin{Verbatim}[commandchars=\\\{\}]
messages:
[
  \PYGZob{}
    stream : {}`sys.stderr{}`
    message: 'Welcome'
    name: 'Harry'
  \PYGZcb{}
  \PYGZob{}
    stream : {}`sys.stdout{}`
    message: 'Welkom'
    name: 'Ruud'
  \PYGZcb{}
  \PYGZob{}
    stream : \$messages[0].stream
    message: 'Bienvenue'
    name: Yves
  \PYGZcb{}
]
\end{Verbatim}

a program to read the configuration would be:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{config} \PYG{k+kn}{import} \PYG{n}{Config}

\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{file}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{simple.cfg}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{cfg} \PYG{o}{=} \PYG{n}{Config}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n}{cfg}\PYG{o}{.}\PYG{n}{messages}\PYG{p}{:}
    \PYG{n}{s} \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{, }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{'} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{m}\PYG{o}{.}\PYG{n}{message}\PYG{p}{,} \PYG{n}{m}\PYG{o}{.}\PYG{n}{name}\PYG{p}{)}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{k}{print} \PYG{o}{\textgreater{}\textgreater{}} \PYG{n}{m}\PYG{o}{.}\PYG{n}{stream}\PYG{p}{,} \PYG{n}{s}
    \PYG{k}{except} \PYG{n+ne}{IOError}\PYG{p}{,} \PYG{n}{e}\PYG{p}{:}
        \PYG{k}{print} \PYG{n}{e}
\end{Verbatim}

which, when run, would yield the console output:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Welcome}\PYG{p}{,} \PYG{n}{Harry}
\PYG{n}{Welkom}\PYG{p}{,} \PYG{n}{Ruud}
\PYG{n}{Bienvenue}\PYG{p}{,} \PYG{n}{Yves}
\end{Verbatim}

See U\{this tutorial\textless{}\href{http://www.red-dove.com/python\_config}{http://www.red-dove.com/python\_config}.html\textbar{}\_blank\textgreater{}\} for more
information.

\#modified for salomeTools
@version: 0.3.7.1

@author: Vinay Sajip

@copyright: Copyright (C) 2004-2007 Vinay Sajip. All Rights Reserved.

@var streamOpener: The default stream opener. This is a factory function which
takes a string (e.g. filename) and returns a stream suitable for reading. If
unable to open the stream, an IOError exception should be thrown.

The default value of this variable is L\{defaultStreamOpener\}. For an example
of how it's used, see test\_config.py (search for streamOpener).
\index{Config (class in src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Config}\pysiglinewithargsret{\strong{class }\code{src.pyconf.}\bfcode{Config}}{\emph{streamOrFile=None}, \emph{parent=None}, \emph{PWD=None}}{}
Bases: {\hyperref[commands/apidoc/src:src.pyconf.Mapping]{\code{src.pyconf.Mapping}}}

This class represents a configuration, and is the only one which clients
need to interface to, under normal circumstances.
\index{Config.Namespace (class in src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Config.Namespace}\pysigline{\strong{class }\bfcode{Namespace}}
Bases: \code{object}

This internal class is used for implementing default namespaces.

An instance acts as a namespace.

\end{fulllineitems}

\index{addNamespace() (src.pyconf.Config method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Config.addNamespace}\pysiglinewithargsret{\code{Config.}\bfcode{addNamespace}}{\emph{ns}, \emph{name=None}}{}
Add a namespace to this configuration which can be used to evaluate
(resolve) dotted-identifier expressions.
@param ns: The namespace to be added.
@type ns: A module or other namespace suitable for passing as an
argument to vars().
@param name: A name for the namespace, which, if specified, provides
an additional level of indirection.
@type name: str

\end{fulllineitems}

\index{getByPath() (src.pyconf.Config method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Config.getByPath}\pysiglinewithargsret{\code{Config.}\bfcode{getByPath}}{\emph{path}}{}
Obtain a value in the configuration via its path.
@param path: The path of the required value
@type path: str
@return the value at the specified path.
@rtype: any
@raise ConfigError: If the path is invalid

\end{fulllineitems}

\index{load() (src.pyconf.Config method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Config.load}\pysiglinewithargsret{\code{Config.}\bfcode{load}}{\emph{stream}}{}
Load the configuration from the specified stream. Multiple streams can
be used to populate the same instance, as long as there are no
clashing keys. The stream is closed.
@param stream: A stream from which the configuration is read.
@type stream: A read-only stream (file-like object).
@raise ConfigError: if keys in the loaded configuration clash with
existing keys.
@raise ConfigFormatError: if there is a syntax error in the stream.

\end{fulllineitems}

\index{removeNamespace() (src.pyconf.Config method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Config.removeNamespace}\pysiglinewithargsret{\code{Config.}\bfcode{removeNamespace}}{\emph{ns}, \emph{name=None}}{}
Remove a namespace added with L\{addNamespace\}.
@param ns: The namespace to be removed.
@param name: The name which was specified when L\{addNamespace\} was
called.
@type name: str

\end{fulllineitems}


\end{fulllineitems}

\index{ConfigError}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigError}\pysigline{\strong{exception }\code{src.pyconf.}\bfcode{ConfigError}}
Bases: \code{exceptions.Exception}

This is the base class of exceptions raised by this module.

\end{fulllineitems}

\index{ConfigFormatError}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigFormatError}\pysigline{\strong{exception }\code{src.pyconf.}\bfcode{ConfigFormatError}}
Bases: {\hyperref[commands/apidoc/src:src.pyconf.ConfigError]{\code{src.pyconf.ConfigError}}}

This is the base class of exceptions raised due to syntax errors in
configurations.

\end{fulllineitems}

\index{ConfigInputStream (class in src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigInputStream}\pysiglinewithargsret{\strong{class }\code{src.pyconf.}\bfcode{ConfigInputStream}}{\emph{stream}}{}
Bases: \code{object}

An input stream which can read either ANSI files with default encoding
or Unicode files with BOMs.

Handles UTF-8, UTF-16LE, UTF-16BE. Could handle UTF-32 if Python had
built-in support.
\index{close() (src.pyconf.ConfigInputStream method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigInputStream.close}\pysiglinewithargsret{\bfcode{close}}{}{}
\end{fulllineitems}

\index{read() (src.pyconf.ConfigInputStream method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigInputStream.read}\pysiglinewithargsret{\bfcode{read}}{\emph{size}}{}
\end{fulllineitems}

\index{readline() (src.pyconf.ConfigInputStream method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigInputStream.readline}\pysiglinewithargsret{\bfcode{readline}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{ConfigList (class in src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigList}\pysigline{\strong{class }\code{src.pyconf.}\bfcode{ConfigList}}
Bases: \code{list}

This class implements an ordered list of configurations and allows you
to try getting the configuration from each entry in turn, returning
the first successfully obtained value.
\index{getByPath() (src.pyconf.ConfigList method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigList.getByPath}\pysiglinewithargsret{\bfcode{getByPath}}{\emph{path}}{}
Obtain a value from the first configuration in the list which defines
it.

@param path: The path of the value to retrieve.
@type path: str
@return: The value from the earliest configuration in the list which
defines it.
@rtype: any
@raise ConfigError: If no configuration in the list has an entry with
the specified path.

\end{fulllineitems}


\end{fulllineitems}

\index{ConfigMerger (class in src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigMerger}\pysiglinewithargsret{\strong{class }\code{src.pyconf.}\bfcode{ConfigMerger}}{\emph{resolver=\textless{}function defaultMergeResolve at 0x2379de8\textgreater{}}}{}
Bases: \code{object}

This class is used for merging two configurations. If a key exists in the
merge operand but not the merge target, then the entry is copied from the
merge operand to the merge target. If a key exists in both configurations,
then a resolver (a callable) is called to decide how to handle the
conflict.
\index{handleMismatch() (src.pyconf.ConfigMerger method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigMerger.handleMismatch}\pysiglinewithargsret{\bfcode{handleMismatch}}{\emph{obj1}, \emph{obj2}}{}
Handle a mismatch between two objects.

@param obj1: The object to merge into.
@type obj1: any
@param obj2: The object to merge.
@type obj2: any

\end{fulllineitems}

\index{merge() (src.pyconf.ConfigMerger method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigMerger.merge}\pysiglinewithargsret{\bfcode{merge}}{\emph{merged}, \emph{mergee}}{}
Merge two configurations. The second configuration is unchanged,
and the first is changed to reflect the results of the merge.

@param merged: The configuration to merge into.
@type merged: L\{Config\}.
@param mergee: The configuration to merge.
@type mergee: L\{Config\}.

\end{fulllineitems}

\index{mergeMapping() (src.pyconf.ConfigMerger method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigMerger.mergeMapping}\pysiglinewithargsret{\bfcode{mergeMapping}}{\emph{map1}, \emph{map2}}{}
Merge two mappings recursively. The second mapping is unchanged,
and the first is changed to reflect the results of the merge.

@param map1: The mapping to merge into.
@type map1: L\{Mapping\}.
@param map2: The mapping to merge.
@type map2: L\{Mapping\}.

\end{fulllineitems}

\index{mergeSequence() (src.pyconf.ConfigMerger method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigMerger.mergeSequence}\pysiglinewithargsret{\bfcode{mergeSequence}}{\emph{seq1}, \emph{seq2}}{}
Merge two sequences. The second sequence is unchanged,
and the first is changed to have the elements of the second
appended to it.

@param seq1: The sequence to merge into.
@type seq1: L\{Sequence\}.
@param seq2: The sequence to merge.
@type seq2: L\{Sequence\}.

\end{fulllineitems}

\index{overwriteKeys() (src.pyconf.ConfigMerger method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigMerger.overwriteKeys}\pysiglinewithargsret{\bfcode{overwriteKeys}}{\emph{map1}, \emph{seq2}}{}
Renint variables. The second mapping is unchanged,
and the first is changed depending the keys of the second mapping.
@param map1: The mapping to reinit keys into.
@type map1: L\{Mapping\}.
@param map2: The mapping container reinit information.
@type map2: L\{Mapping\}.

\end{fulllineitems}


\end{fulllineitems}

\index{ConfigOutputStream (class in src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigOutputStream}\pysiglinewithargsret{\strong{class }\code{src.pyconf.}\bfcode{ConfigOutputStream}}{\emph{stream}, \emph{encoding=None}}{}
Bases: \code{object}

An output stream which can write either ANSI files with default encoding
or Unicode files with BOMs.

Handles UTF-8, UTF-16LE, UTF-16BE. Could handle UTF-32 if Python had
built-in support.
\index{close() (src.pyconf.ConfigOutputStream method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigOutputStream.close}\pysiglinewithargsret{\bfcode{close}}{}{}
\end{fulllineitems}

\index{flush() (src.pyconf.ConfigOutputStream method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigOutputStream.flush}\pysiglinewithargsret{\bfcode{flush}}{}{}
\end{fulllineitems}

\index{write() (src.pyconf.ConfigOutputStream method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigOutputStream.write}\pysiglinewithargsret{\bfcode{write}}{\emph{data}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{ConfigReader (class in src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigReader}\pysiglinewithargsret{\strong{class }\code{src.pyconf.}\bfcode{ConfigReader}}{\emph{config}}{}
Bases: \code{object}

This internal class implements a parser for configurations.
\index{getChar() (src.pyconf.ConfigReader method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigReader.getChar}\pysiglinewithargsret{\bfcode{getChar}}{}{}
Get the next char from the stream. Update line and column numbers
appropriately.

@return: The next character from the stream.
@rtype: str

\end{fulllineitems}

\index{getToken() (src.pyconf.ConfigReader method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigReader.getToken}\pysiglinewithargsret{\bfcode{getToken}}{}{}
Get a token from the stream. String values are returned in a form
where you need to eval() the returned value to get the actual
string. The return value is (token\_type, token\_value).

Multiline string tokenizing is thanks to David Janes (BlogMatrix)

@return: The next token.
@rtype: A token tuple.

\end{fulllineitems}

\index{load() (src.pyconf.ConfigReader method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigReader.load}\pysiglinewithargsret{\bfcode{load}}{\emph{stream}, \emph{parent=None}, \emph{suffix=None}}{}
Load the configuration from the specified stream.

@param stream: A stream from which to load the configuration.
@type stream: A stream (file-like object).
@param parent: The parent of the configuration (to which this reader
belongs) in the hierarchy. Specified when the configuration is
included in another one.
@type parent: A L\{Container\} instance.
@param suffix: The suffix of this configuration in the parent
configuration. Should be specified whenever the parent is not None.
@raise ConfigError: If parent is specified but suffix is not.
@raise ConfigFormatError: If there are syntax errors in the stream.

\end{fulllineitems}

\index{location() (src.pyconf.ConfigReader method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigReader.location}\pysiglinewithargsret{\bfcode{location}}{}{}
Return the current location (filename, line, column) in the stream
as a string.

Used when printing error messages,

@return: A string representing a location in the stream being read.
@rtype: str

\end{fulllineitems}

\index{match() (src.pyconf.ConfigReader method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigReader.match}\pysiglinewithargsret{\bfcode{match}}{\emph{t}}{}
Ensure that the current token type matches the specified value, and
advance to the next token.

@param t: The token type to match.
@type t: A valid token type.
@return: The token which was last read from the stream before this
function is called.
@rtype: a token tuple - see L\{getToken\}.
@raise ConfigFormatError: If the token does not match what's expected.

\end{fulllineitems}

\index{parseFactor() (src.pyconf.ConfigReader method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigReader.parseFactor}\pysiglinewithargsret{\bfcode{parseFactor}}{}{}
Parse a factor in an multiplicative expression (a * b, a / b, a \% b)

@return: the parsed factor
@rtype: any scalar
@raise ConfigFormatError: if a syntax error is found.

\end{fulllineitems}

\index{parseKeyValuePair() (src.pyconf.ConfigReader method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigReader.parseKeyValuePair}\pysiglinewithargsret{\bfcode{parseKeyValuePair}}{\emph{parent}}{}
Parse a key-value pair, and add it to the provided L\{Mapping\}.

@param parent: The mapping to add entries to.
@type parent: A L\{Mapping\} instance.
@raise ConfigFormatError: if a syntax error is found.

\end{fulllineitems}

\index{parseMapping() (src.pyconf.ConfigReader method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigReader.parseMapping}\pysiglinewithargsret{\bfcode{parseMapping}}{\emph{parent}, \emph{suffix}}{}
Parse a mapping.

@param parent: The container to which the mapping will be added.
@type parent: A L\{Container\} instance.
@param suffix: The suffix for the value.
@type suffix: str
@return: a L\{Mapping\} instance representing the mapping.
@rtype: L\{Mapping\}
@raise ConfigFormatError: if a syntax error is found.

\end{fulllineitems}

\index{parseMappingBody() (src.pyconf.ConfigReader method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigReader.parseMappingBody}\pysiglinewithargsret{\bfcode{parseMappingBody}}{\emph{parent}}{}
Parse the internals of a mapping, and add entries to the provided
L\{Mapping\}.

@param parent: The mapping to add entries to.
@type parent: A L\{Mapping\} instance.

\end{fulllineitems}

\index{parseReference() (src.pyconf.ConfigReader method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigReader.parseReference}\pysiglinewithargsret{\bfcode{parseReference}}{\emph{type}}{}
Parse a reference.

@return: the parsed reference
@rtype: L\{Reference\}
@raise ConfigFormatError: if a syntax error is found.

\end{fulllineitems}

\index{parseScalar() (src.pyconf.ConfigReader method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigReader.parseScalar}\pysiglinewithargsret{\bfcode{parseScalar}}{}{}
Parse a scalar - a terminal value such as a string or number, or
an L\{Expression\} or L\{Reference\}.

@return: the parsed scalar
@rtype: any scalar
@raise ConfigFormatError: if a syntax error is found.

\end{fulllineitems}

\index{parseSequence() (src.pyconf.ConfigReader method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigReader.parseSequence}\pysiglinewithargsret{\bfcode{parseSequence}}{\emph{parent}, \emph{suffix}}{}
Parse a sequence.

@param parent: The container to which the sequence will be added.
@type parent: A L\{Container\} instance.
@param suffix: The suffix for the value.
@type suffix: str
@return: a L\{Sequence\} instance representing the sequence.
@rtype: L\{Sequence\}
@raise ConfigFormatError: if a syntax error is found.

\end{fulllineitems}

\index{parseSuffix() (src.pyconf.ConfigReader method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigReader.parseSuffix}\pysiglinewithargsret{\bfcode{parseSuffix}}{\emph{ref}}{}
Parse a reference suffix.

@param ref: The reference of which this suffix is a part.
@type ref: L\{Reference\}.
@raise ConfigFormatError: if a syntax error is found.

\end{fulllineitems}

\index{parseTerm() (src.pyconf.ConfigReader method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigReader.parseTerm}\pysiglinewithargsret{\bfcode{parseTerm}}{}{}
Parse a term in an additive expression (a + b, a - b)

@return: the parsed term
@rtype: any scalar
@raise ConfigFormatError: if a syntax error is found.

\end{fulllineitems}

\index{parseValue() (src.pyconf.ConfigReader method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigReader.parseValue}\pysiglinewithargsret{\bfcode{parseValue}}{\emph{parent}, \emph{suffix}}{}
Parse a value.

@param parent: The container to which the value will be added.
@type parent: A L\{Container\} instance.
@param suffix: The suffix for the value.
@type suffix: str
@return: The value
@rtype: any
@raise ConfigFormatError: if a syntax error is found.

\end{fulllineitems}

\index{setStream() (src.pyconf.ConfigReader method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigReader.setStream}\pysiglinewithargsret{\bfcode{setStream}}{\emph{stream}}{}
Set the stream to the specified value, and prepare to read from it.

@param stream: A stream from which to load the configuration.
@type stream: A stream (file-like object).

\end{fulllineitems}


\end{fulllineitems}

\index{ConfigResolutionError}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.ConfigResolutionError}\pysigline{\strong{exception }\code{src.pyconf.}\bfcode{ConfigResolutionError}}
Bases: {\hyperref[commands/apidoc/src:src.pyconf.ConfigError]{\code{src.pyconf.ConfigError}}}

This is the base class of exceptions raised due to semantic errors in
configurations.

\end{fulllineitems}

\index{Container (class in src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Container}\pysiglinewithargsret{\strong{class }\code{src.pyconf.}\bfcode{Container}}{\emph{parent}}{}
Bases: \code{object}

This internal class is the base class for mappings and sequences.

@ivar path: A string which describes how to get
to this instance from the root of the hierarchy.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
a.list.of[1].or['more'].elements
\end{Verbatim}
\index{evaluate() (src.pyconf.Container method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Container.evaluate}\pysiglinewithargsret{\bfcode{evaluate}}{\emph{item}}{}
Evaluate items which are instances of L\{Reference\} or L\{Expression\}.

L\{Reference\} instances are evaluated using L\{Reference.resolve\},
and L\{Expression\} instances are evaluated using
L\{Expression.evaluate\}.

@param item: The item to be evaluated.
@type item: any
@return: If the item is an instance of L\{Reference\} or L\{Expression\},
the evaluated value is returned, otherwise the item is returned
unchanged.

\end{fulllineitems}

\index{setPath() (src.pyconf.Container method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Container.setPath}\pysiglinewithargsret{\bfcode{setPath}}{\emph{path}}{}
Set the path for this instance.
@param path: The path - a string which describes how to get
to this instance from the root of the hierarchy.
@type path: str

\end{fulllineitems}

\index{writeToStream() (src.pyconf.Container method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Container.writeToStream}\pysiglinewithargsret{\bfcode{writeToStream}}{\emph{stream}, \emph{indent}, \emph{container}}{}
Write this instance to a stream at the specified indentation level.

Should be redefined in subclasses.

@param stream: The stream to write to
@type stream: A writable stream (file-like object)
@param indent: The indentation level
@type indent: int
@param container: The container of this instance
@type container: L\{Container\}
@raise NotImplementedError: If a subclass does not override this

\end{fulllineitems}

\index{writeValue() (src.pyconf.Container method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Container.writeValue}\pysiglinewithargsret{\bfcode{writeValue}}{\emph{value}, \emph{stream}, \emph{indent}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Expression (class in src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Expression}\pysiglinewithargsret{\strong{class }\code{src.pyconf.}\bfcode{Expression}}{\emph{op}, \emph{lhs}, \emph{rhs}}{}
Bases: \code{object}

This internal class implements a value which is obtained by evaluating an expression.
\index{evaluate() (src.pyconf.Expression method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Expression.evaluate}\pysiglinewithargsret{\bfcode{evaluate}}{\emph{container}}{}
Evaluate this instance in the context of a container.

@param container: The container to evaluate in from.
@type container: L\{Container\}
@return: The evaluated value.
@rtype: any
@raise ConfigResolutionError: If evaluation fails.
@raise ZeroDivideError: If division by zero occurs.
@raise TypeError: If the operation is invalid, e.g.
subtracting one string from another.

\end{fulllineitems}


\end{fulllineitems}

\index{Mapping (class in src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Mapping}\pysiglinewithargsret{\strong{class }\code{src.pyconf.}\bfcode{Mapping}}{\emph{parent=None}}{}
Bases: {\hyperref[commands/apidoc/src:src.pyconf.Container]{\code{src.pyconf.Container}}}

This internal class implements key-value mappings in configurations.
\index{addMapping() (src.pyconf.Mapping method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Mapping.addMapping}\pysiglinewithargsret{\bfcode{addMapping}}{\emph{key}, \emph{value}, \emph{comment}, \emph{setting=False}}{}
Add a key-value mapping with a comment.

@param key: The key for the mapping.
@type key: str
@param value: The value for the mapping.
@type value: any
@param comment: The comment for the key (can be None).
@type comment: str
@param setting: If True, ignore clashes. This is set
to true when called from L\{\_\_setattr\_\_\}.
@raise ConfigFormatError: If an existing key is seen
again and setting is False.

\end{fulllineitems}

\index{get() (src.pyconf.Mapping method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Mapping.get}\pysiglinewithargsret{\bfcode{get}}{\emph{key}, \emph{default=None}}{}
Allows a dictionary-style get operation.

\end{fulllineitems}

\index{iteritems() (src.pyconf.Mapping method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Mapping.iteritems}\pysiglinewithargsret{\bfcode{iteritems}}{}{}
\end{fulllineitems}

\index{iterkeys() (src.pyconf.Mapping method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Mapping.iterkeys}\pysiglinewithargsret{\bfcode{iterkeys}}{}{}
\end{fulllineitems}

\index{keys() (src.pyconf.Mapping method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Mapping.keys}\pysiglinewithargsret{\bfcode{keys}}{}{}
Return the keys in a similar way to a dictionary.

\end{fulllineitems}

\index{writeToStream() (src.pyconf.Mapping method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Mapping.writeToStream}\pysiglinewithargsret{\bfcode{writeToStream}}{\emph{stream}, \emph{indent}, \emph{container}}{}
Write this instance to a stream at the specified indentation level.

Should be redefined in subclasses.

@param stream: The stream to write to
@type stream: A writable stream (file-like object)
@param indent: The indentation level
@type indent: int
@param container: The container of this instance
@type container: L\{Container\}

\end{fulllineitems}


\end{fulllineitems}

\index{Reference (class in src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Reference}\pysiglinewithargsret{\strong{class }\code{src.pyconf.}\bfcode{Reference}}{\emph{config}, \emph{type}, \emph{ident}}{}
Bases: \code{object}

This internal class implements a value which is a reference to another value.
\index{addElement() (src.pyconf.Reference method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Reference.addElement}\pysiglinewithargsret{\bfcode{addElement}}{\emph{type}, \emph{ident}}{}
Add an element to the reference.

@param type: The type of reference.
@type type: BACKTICK or DOLLAR
@param ident: The identifier which continues the reference.
@type ident: str

\end{fulllineitems}

\index{findConfig() (src.pyconf.Reference method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Reference.findConfig}\pysiglinewithargsret{\bfcode{findConfig}}{\emph{container}}{}
Find the closest enclosing configuration to the specified container.

@param container: The container to start from.
@type container: L\{Container\}
@return: The closest enclosing configuration, or None.
@rtype: L\{Config\}

\end{fulllineitems}

\index{resolve() (src.pyconf.Reference method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Reference.resolve}\pysiglinewithargsret{\bfcode{resolve}}{\emph{container}}{}
Resolve this instance in the context of a container.

@param container: The container to resolve from.
@type container: L\{Container\}
@return: The resolved value.
@rtype: any
@raise ConfigResolutionError: If resolution fails.

\end{fulllineitems}


\end{fulllineitems}

\index{Sequence (class in src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Sequence}\pysiglinewithargsret{\strong{class }\code{src.pyconf.}\bfcode{Sequence}}{\emph{parent=None}}{}
Bases: {\hyperref[commands/apidoc/src:src.pyconf.Container]{\code{src.pyconf.Container}}}

This internal class implements a value which is a sequence of other values.
\index{Sequence.SeqIter (class in src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Sequence.SeqIter}\pysiglinewithargsret{\strong{class }\bfcode{SeqIter}}{\emph{seq}}{}
Bases: \code{object}

This internal class implements an iterator for a L\{Sequence\} instance.
\index{next() (src.pyconf.Sequence.SeqIter method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Sequence.SeqIter.next}\pysiglinewithargsret{\bfcode{next}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{append() (src.pyconf.Sequence method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Sequence.append}\pysiglinewithargsret{\code{Sequence.}\bfcode{append}}{\emph{item}, \emph{comment}}{}
Add an item to the sequence.

@param item: The item to add.
@type item: any
@param comment: A comment for the item.
@type comment: str

\end{fulllineitems}

\index{writeToStream() (src.pyconf.Sequence method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.Sequence.writeToStream}\pysiglinewithargsret{\code{Sequence.}\bfcode{writeToStream}}{\emph{stream}, \emph{indent}, \emph{container}}{}
Write this instance to a stream at the specified indentation level.

Should be redefined in subclasses.

@param stream: The stream to write to
@type stream: A writable stream (file-like object)
@param indent: The indentation level
@type indent: int
@param container: The container of this instance
@type container: L\{Container\}

\end{fulllineitems}


\end{fulllineitems}

\index{deepCopyMapping() (in module src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.deepCopyMapping}\pysiglinewithargsret{\code{src.pyconf.}\bfcode{deepCopyMapping}}{\emph{inMapping}}{}
\end{fulllineitems}

\index{defaultMergeResolve() (in module src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.defaultMergeResolve}\pysiglinewithargsret{\code{src.pyconf.}\bfcode{defaultMergeResolve}}{\emph{map1}, \emph{map2}, \emph{key}}{}
A default resolver for merge conflicts. 
Returns a string indicating what action to take to resolve the conflict.

@param map1: The map being merged into.
@type map1: L\{Mapping\}.
@param map2: The map being used as the merge operand.
@type map2: L\{Mapping\}.
@param key: The key in map2 (which also exists in map1).
@type key: str
\begin{description}
\item[{@return: One of ``merge'', ``append'', ``mismatch'' or ``overwrite''}] \leavevmode
indicating what action should be taken. This should
be appropriate to the objects being merged - e.g.
there is no point returning ``merge'' if the two objects
are instances of L\{Sequence\}.

\end{description}

@rtype: str

\end{fulllineitems}

\index{defaultStreamOpener() (in module src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.defaultStreamOpener}\pysiglinewithargsret{\code{src.pyconf.}\bfcode{defaultStreamOpener}}{\emph{name}}{}
This function returns a read-only stream, given its name. The name passed
in should correspond to an existing stream, otherwise an exception will be
raised.

This is the default value of L\{streamOpener\}; assign your own callable to
streamOpener to return streams based on names. For example, you could use
urllib2.urlopen().

@param name: The name of a stream, most commonly a file name.
@type name: str
@return: A stream with the specified name.
@rtype: A read-only stream (file-like object)

\end{fulllineitems}

\index{isWord() (in module src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.isWord}\pysiglinewithargsret{\code{src.pyconf.}\bfcode{isWord}}{\emph{s}}{}
See if a passed-in value is an identifier. If the value passed in is not a
string, False is returned. An identifier consists of alphanumerics or
underscore characters.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
isWord('a word') -\textgreater{}False
isWord('award') -\textgreater{} True
isWord(9) -\textgreater{} False
isWord('a\_b\_c\_') -\textgreater{}True
\end{Verbatim}

@note: isWord(`9abc') will return True - not exactly correct, but adequate
for the way it's used here.

@param s: The name to be tested
@type s: any
@return: True if a word, else False
@rtype: bool

\end{fulllineitems}

\index{makePath() (in module src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.makePath}\pysiglinewithargsret{\code{src.pyconf.}\bfcode{makePath}}{\emph{prefix}, \emph{suffix}}{}
Make a path from a prefix and suffix.

Examples:
makePath(`', `suffix') -\textgreater{} `suffix'
makePath(`prefix', `suffix') -\textgreater{} `prefix.suffix'
makePath(`prefix', `{[}1{]}') -\textgreater{} `prefix{[}1{]}'

@param prefix: The prefix to use. If it evaluates as false, the suffix is returned.
@type prefix: str
@param suffix: The suffix to use. It is either an identifier or an index in brackets.
@type suffix: str
@return: The path concatenation of prefix and suffix, with adot if the suffix is not a bracketed index.
@rtype: str

\end{fulllineitems}

\index{overwriteMergeResolve() (in module src.pyconf)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.pyconf.overwriteMergeResolve}\pysiglinewithargsret{\code{src.pyconf.}\bfcode{overwriteMergeResolve}}{\emph{map1}, \emph{map2}, \emph{key}}{}
An overwriting resolver for merge conflicts. Calls L\{defaultMergeResolve\},
but where a ``mismatch'' is detected, returns ``overwrite'' instead.

@param map1: The map being merged into.
@type map1: L\{Mapping\}.
@param map2: The map being used as the merge operand.
@type map2: L\{Mapping\}.
@param key: The key in map2 (which also exists in map1).
@type key: str

\end{fulllineitems}



\subsubsection{\texttt{system} Module}
\label{commands/apidoc/src:system-module}\label{commands/apidoc/src:module-src.system}\index{src.system (module)}
In this file : all functions that do a system call, 
like open a browser or an editor, or call a git command
\index{archive\_extract() (in module src.system)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.system.archive_extract}\pysiglinewithargsret{\code{src.system.}\bfcode{archive\_extract}}{\emph{from\_what}, \emph{where}, \emph{logger}}{}
Extracts sources from an archive.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{where}) -- The path to the archive.

\item {} 
\textbf{str} -- The path where to extract.

\item {} 
\textbf{Logger} (\emph{logger}) -- The logger instance to use.

\end{itemize}

\item[{Returns}] \leavevmode
True if the extraction is successful

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{cvs\_extract() (in module src.system)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.system.cvs_extract}\pysiglinewithargsret{\code{src.system.}\bfcode{cvs\_extract}}{\emph{protocol}, \emph{user}, \emph{server}, \emph{base}, \emph{tag}, \emph{product}, \emph{where}, \emph{logger}, \emph{checkout=False}, \emph{environment=None}}{}
Extracts sources from a cvs repository.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{where}) -- The cvs protocol.

\item {} 
\textbf{str} -- The user to be used.

\item {} 
\textbf{str} -- The remote cvs server.

\item {} 
\textbf{str} -- 
.


\item {} 
\textbf{str} -- The tag.

\item {} 
\textbf{str} -- The product.

\item {} 
\textbf{str} -- The path where to extract.

\item {} 
\textbf{Logger} (\emph{logger}) -- The logger instance to use.

\item {} 
\textbf{boolean} (\emph{checkout}) -- If true use checkout cvs.

\item {} 
\textbf{src.environment.Environ} (\emph{environment}) -- The environment to source when
extracting.

\end{itemize}

\item[{Returns}] \leavevmode
True if the extraction is successful

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{git\_extract() (in module src.system)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.system.git_extract}\pysiglinewithargsret{\code{src.system.}\bfcode{git\_extract}}{\emph{from\_what}, \emph{tag}, \emph{where}, \emph{logger}, \emph{environment=None}}{}
Extracts sources from a git repository.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{where}) -- The remote git repository.

\item {} 
\textbf{str} -- The tag.

\item {} 
\textbf{str} -- The path where to extract.

\item {} 
\textbf{Logger} (\emph{logger}) -- The logger instance to use.

\item {} 
\textbf{src.environment.Environ} (\emph{environment}) -- The environment to source when
extracting.

\end{itemize}

\item[{Returns}] \leavevmode
True if the extraction is successful

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{show\_in\_editor() (in module src.system)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.system.show_in_editor}\pysiglinewithargsret{\code{src.system.}\bfcode{show\_in\_editor}}{\emph{editor}, \emph{filePath}, \emph{logger}}{}
open filePath using editor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{filePath}) -- The editor to use.

\item {} 
\textbf{str} -- The path to the file to open.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{svn\_extract() (in module src.system)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.system.svn_extract}\pysiglinewithargsret{\code{src.system.}\bfcode{svn\_extract}}{\emph{user}, \emph{from\_what}, \emph{tag}, \emph{where}, \emph{logger}, \emph{checkout=False}, \emph{environment=None}}{}
Extracts sources from a svn repository.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{where}) -- The user to be used.

\item {} 
\textbf{str} -- The remote git repository.

\item {} 
\textbf{str} -- The tag.

\item {} 
\textbf{str} -- The path where to extract.

\item {} 
\textbf{Logger} (\emph{logger}) -- The logger instance to use.

\item {} 
\textbf{boolean} (\emph{checkout}) -- If true use checkout svn.

\item {} 
\textbf{src.environment.Environ} (\emph{environment}) -- The environment to source when
extracting.

\end{itemize}

\item[{Returns}] \leavevmode
True if the extraction is successful

\item[{Return type}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{\texttt{template} Module}
\label{commands/apidoc/src:template-module}\label{commands/apidoc/src:module-src.template}\index{src.template (module)}\index{MyTemplate (class in src.template)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.template.MyTemplate}\pysiglinewithargsret{\strong{class }\code{src.template.}\bfcode{MyTemplate}}{\emph{template}}{}
Bases: \code{string.Template}
\index{delimiter (src.template.MyTemplate attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.template.MyTemplate.delimiter}\pysigline{\bfcode{delimiter}\strong{ = `\textbackslash{}xc2\textbackslash{}xa4'}}
\end{fulllineitems}

\index{pattern (src.template.MyTemplate attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.template.MyTemplate.pattern}\pysigline{\bfcode{pattern}\strong{ = \textless{}\_sre.SRE\_Pattern object at 0x24c9d70\textgreater{}}}
\end{fulllineitems}


\end{fulllineitems}

\index{substitute() (in module src.template)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.template.substitute}\pysiglinewithargsret{\code{src.template.}\bfcode{substitute}}{\emph{template\_file}, \emph{subst\_dic}}{}
\end{fulllineitems}



\subsubsection{\texttt{test\_module} Module}
\label{commands/apidoc/src:module-src.test_module}\label{commands/apidoc/src:test-module-module}\index{src.test\_module (module)}\index{Test (class in src.test\_module)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test}\pysiglinewithargsret{\strong{class }\code{src.test\_module.}\bfcode{Test}}{\emph{config}, \emph{logger}, \emph{tmp\_working\_dir}, \emph{testbase='`}, \emph{grids=None}, \emph{sessions=None}, \emph{launcher='`}, \emph{show\_desktop=True}}{}~\index{generate\_launching\_commands() (src.test\_module.Test method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test.generate_launching_commands}\pysiglinewithargsret{\bfcode{generate\_launching\_commands}}{}{}
\end{fulllineitems}

\index{generate\_script() (src.test\_module.Test method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test.generate_script}\pysiglinewithargsret{\bfcode{generate\_script}}{\emph{listTest}, \emph{script\_path}, \emph{ignoreList}}{}
\end{fulllineitems}

\index{get\_test\_timeout() (src.test\_module.Test method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test.get_test_timeout}\pysiglinewithargsret{\bfcode{get\_test\_timeout}}{\emph{test\_name}, \emph{default\_value}}{}
\end{fulllineitems}

\index{get\_tmp\_dir() (src.test\_module.Test method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test.get_tmp_dir}\pysiglinewithargsret{\bfcode{get\_tmp\_dir}}{}{}
\end{fulllineitems}

\index{prepare\_testbase() (src.test\_module.Test method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test.prepare_testbase}\pysiglinewithargsret{\bfcode{prepare\_testbase}}{\emph{test\_base\_name}}{}
\end{fulllineitems}

\index{prepare\_testbase\_from\_dir() (src.test\_module.Test method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test.prepare_testbase_from_dir}\pysiglinewithargsret{\bfcode{prepare\_testbase\_from\_dir}}{\emph{testbase\_name}, \emph{testbase\_dir}}{}
\end{fulllineitems}

\index{prepare\_testbase\_from\_git() (src.test\_module.Test method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test.prepare_testbase_from_git}\pysiglinewithargsret{\bfcode{prepare\_testbase\_from\_git}}{\emph{testbase\_name}, \emph{testbase\_base}, \emph{testbase\_tag}}{}
\end{fulllineitems}

\index{prepare\_testbase\_from\_svn() (src.test\_module.Test method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test.prepare_testbase_from_svn}\pysiglinewithargsret{\bfcode{prepare\_testbase\_from\_svn}}{\emph{user}, \emph{testbase\_name}, \emph{testbase\_base}}{}
\end{fulllineitems}

\index{read\_results() (src.test\_module.Test method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test.read_results}\pysiglinewithargsret{\bfcode{read\_results}}{\emph{listTest}, \emph{has\_timed\_out}}{}
\end{fulllineitems}

\index{run\_all\_tests() (src.test\_module.Test method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test.run_all_tests}\pysiglinewithargsret{\bfcode{run\_all\_tests}}{}{}
\end{fulllineitems}

\index{run\_grid\_tests() (src.test\_module.Test method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test.run_grid_tests}\pysiglinewithargsret{\bfcode{run\_grid\_tests}}{}{}
\end{fulllineitems}

\index{run\_script() (src.test\_module.Test method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test.run_script}\pysiglinewithargsret{\bfcode{run\_script}}{\emph{script\_name}}{}
\end{fulllineitems}

\index{run\_session\_tests() (src.test\_module.Test method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test.run_session_tests}\pysiglinewithargsret{\bfcode{run\_session\_tests}}{}{}
\end{fulllineitems}

\index{run\_testbase\_tests() (src.test\_module.Test method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test.run_testbase_tests}\pysiglinewithargsret{\bfcode{run\_testbase\_tests}}{}{}
\end{fulllineitems}

\index{run\_tests() (src.test\_module.Test method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test.run_tests}\pysiglinewithargsret{\bfcode{run\_tests}}{\emph{listTest}, \emph{ignoreList}}{}
\end{fulllineitems}

\index{search\_known\_errors() (src.test\_module.Test method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test.search_known_errors}\pysiglinewithargsret{\bfcode{search\_known\_errors}}{\emph{status}, \emph{test\_grid}, \emph{test\_session}, \emph{test}}{}
\end{fulllineitems}

\index{write\_test\_margin() (src.test\_module.Test method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.Test.write_test_margin}\pysiglinewithargsret{\bfcode{write\_test\_margin}}{\emph{tab}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{getTmpDirDEFAULT() (in module src.test\_module)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.test_module.getTmpDirDEFAULT}\pysiglinewithargsret{\code{src.test\_module.}\bfcode{getTmpDirDEFAULT}}{}{}
\end{fulllineitems}



\subsubsection{\texttt{xmlManager} Module}
\label{commands/apidoc/src:xmlmanager-module}\label{commands/apidoc/src:module-src.xmlManager}\index{src.xmlManager (module)}\index{ReadXmlFile (class in src.xmlManager)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.xmlManager.ReadXmlFile}\pysiglinewithargsret{\strong{class }\code{src.xmlManager.}\bfcode{ReadXmlFile}}{\emph{filePath}}{}
Bases: \code{object}

Class to manage reading of an xml log file
\index{getRootAttrib() (src.xmlManager.ReadXmlFile method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.xmlManager.ReadXmlFile.getRootAttrib}\pysiglinewithargsret{\bfcode{getRootAttrib}}{}{}
Get the attibutes of the self.xmlroot
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The attributes of the root node

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_attrib() (src.xmlManager.ReadXmlFile method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.xmlManager.ReadXmlFile.get_attrib}\pysiglinewithargsret{\bfcode{get\_attrib}}{\emph{node\_name}}{}
Get the attibutes of the node node\_name in self.xmlroot
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{node\_name}) -- the name of the node

\item[{Returns}] \leavevmode
the attibutes of the node node\_name in self.xmlroot

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_node\_text() (src.xmlManager.ReadXmlFile method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.xmlManager.ReadXmlFile.get_node_text}\pysiglinewithargsret{\bfcode{get\_node\_text}}{\emph{node}}{}
Get the text of the first node that has name 
that corresponds to the parameter node
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{node}) -- the name of the node from which get the text

\item[{Returns}] \leavevmode
the text of the first node that has name 
that corresponds to the parameter node

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{XmlLogFile (class in src.xmlManager)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.xmlManager.XmlLogFile}\pysiglinewithargsret{\strong{class }\code{src.xmlManager.}\bfcode{XmlLogFile}}{\emph{filePath}, \emph{rootname}, \emph{attrib=\{\}}}{}
Bases: \code{object}

Class to manage writing in salomeTools xml log file
\index{add\_simple\_node() (src.xmlManager.XmlLogFile method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.xmlManager.XmlLogFile.add_simple_node}\pysiglinewithargsret{\bfcode{add\_simple\_node}}{\emph{node\_name}, \emph{text=None}, \emph{attrib=\{\}}}{}
Add a node with some attibutes and text to the root node.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{text}) -- the name of the node to add

\item {} 
\textbf{str} -- the text of the node

\item {} 
\textbf{dict} (\emph{attrib}) -- the dictionary containing the 
attribute of the new node

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{append\_node\_attrib() (src.xmlManager.XmlLogFile method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.xmlManager.XmlLogFile.append_node_attrib}\pysiglinewithargsret{\bfcode{append\_node\_attrib}}{\emph{node\_name}, \emph{attrib}}{}
Append a new attributes to the node that has node\_name as name
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{node\_name}) -- The name of the node on which append text

\item {} 
\textbf{dixt} (\emph{attrib}) -- The attrib to append

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{append\_node\_text() (src.xmlManager.XmlLogFile method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.xmlManager.XmlLogFile.append_node_text}\pysiglinewithargsret{\bfcode{append\_node\_text}}{\emph{node\_name}, \emph{text}}{}
Append a new text to the node that has node\_name as name
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{text}) -- The name of the node on which append text

\item {} 
\textbf{str} -- The text to append

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_tree() (src.xmlManager.XmlLogFile method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.xmlManager.XmlLogFile.write_tree}\pysiglinewithargsret{\bfcode{write\_tree}}{\emph{stylesheet=None}, \emph{file\_path=None}}{}
Write the xml tree in the log file path. Add the stylesheet if asked.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{str} (\emph{stylesheet}) -- The stylesheet to apply to the xml file

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{add\_simple\_node() (in module src.xmlManager)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.xmlManager.add_simple_node}\pysiglinewithargsret{\code{src.xmlManager.}\bfcode{add\_simple\_node}}{\emph{root\_node}, \emph{node\_name}, \emph{text=None}, \emph{attrib=\{\}}}{}
Add a node with some attibutes and text to the root node.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{etree.Element} (\emph{root\_node}) -- the Etree element where to add the new node

\item {} 
\textbf{str} (\emph{text}) -- the name of the node to add

\item {} 
\textbf{str} -- the text of the node

\item {} 
\textbf{dict} (\emph{attrib}) -- the dictionary containing the 
attribute of the new node

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{append\_node\_attrib() (in module src.xmlManager)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.xmlManager.append_node_attrib}\pysiglinewithargsret{\code{src.xmlManager.}\bfcode{append\_node\_attrib}}{\emph{root\_node}, \emph{attrib}}{}
Append a new attributes to the node that has node\_name as name
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{etree.Element} (\emph{root\_node}) -- the Etree element 
where to append the new attibutes

\item {} 
\textbf{dixt} (\emph{attrib}) -- The attrib to append

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_node\_by\_attrib() (in module src.xmlManager)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.xmlManager.find_node_by_attrib}\pysiglinewithargsret{\code{src.xmlManager.}\bfcode{find\_node\_by\_attrib}}{\emph{xmlroot}, \emph{name\_node}, \emph{key}, \emph{value}}{}
Find the nfirst ode from xmlroot that has name name\_node and that has in 
its attributes \{key : value\}. Return the node
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{etree.Element} (\emph{xmlroot}) -- the Etree element where to search

\item {} 
\textbf{str} (\emph{value}) -- the name of node to search

\item {} 
\textbf{str} -- the key to search

\item {} 
\textbf{str} -- the value to search

\end{itemize}

\item[{Returns}] \leavevmode
the found node

\item[{Return type}] \leavevmode
xmlroot etree.Element

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_report() (in module src.xmlManager)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src:src.xmlManager.write_report}\pysiglinewithargsret{\code{src.xmlManager.}\bfcode{write\_report}}{\emph{filename}, \emph{xmlroot}, \emph{stylesheet}}{}
Writes a report file from a XML tree.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{str} (\emph{stylesheet}) -- The path to the file to create

\item {} 
\textbf{etree.Element} (\emph{xmlroot}) -- the Etree element to write to the file

\item {} 
\textbf{str} -- The stylesheet to add to the begin of the file

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{Subpackages}
\label{commands/apidoc/src:subpackages}

\paragraph{colorama Package}
\label{commands/apidoc/src.colorama:colorama-package}\label{commands/apidoc/src.colorama::doc}

\subparagraph{\texttt{colorama} Package}
\label{commands/apidoc/src.colorama:id1}\phantomsection\label{commands/apidoc/src.colorama:module-src.colorama}\index{src.colorama (module)}

\subparagraph{\texttt{ansi} Module}
\label{commands/apidoc/src.colorama:module-src.colorama.ansi}\label{commands/apidoc/src.colorama:ansi-module}\index{src.colorama.ansi (module)}
This module generates ANSI character codes to printing colors to terminals.
See: \href{http://en.wikipedia.org/wiki/ANSI\_escape\_code}{http://en.wikipedia.org/wiki/ANSI\_escape\_code}
\index{AnsiBack (class in src.colorama.ansi)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack}\pysigline{\strong{class }\code{src.colorama.ansi.}\bfcode{AnsiBack}}
Bases: {\hyperref[commands/apidoc/src.colorama:src.colorama.ansi.AnsiCodes]{\code{src.colorama.ansi.AnsiCodes}}}
\index{BLACK (src.colorama.ansi.AnsiBack attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack.BLACK}\pysigline{\bfcode{BLACK}\strong{ = 40}}
\end{fulllineitems}

\index{BLUE (src.colorama.ansi.AnsiBack attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack.BLUE}\pysigline{\bfcode{BLUE}\strong{ = 44}}
\end{fulllineitems}

\index{CYAN (src.colorama.ansi.AnsiBack attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack.CYAN}\pysigline{\bfcode{CYAN}\strong{ = 46}}
\end{fulllineitems}

\index{GREEN (src.colorama.ansi.AnsiBack attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack.GREEN}\pysigline{\bfcode{GREEN}\strong{ = 42}}
\end{fulllineitems}

\index{LIGHTBLACK\_EX (src.colorama.ansi.AnsiBack attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack.LIGHTBLACK_EX}\pysigline{\bfcode{LIGHTBLACK\_EX}\strong{ = 100}}
\end{fulllineitems}

\index{LIGHTBLUE\_EX (src.colorama.ansi.AnsiBack attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack.LIGHTBLUE_EX}\pysigline{\bfcode{LIGHTBLUE\_EX}\strong{ = 104}}
\end{fulllineitems}

\index{LIGHTCYAN\_EX (src.colorama.ansi.AnsiBack attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack.LIGHTCYAN_EX}\pysigline{\bfcode{LIGHTCYAN\_EX}\strong{ = 106}}
\end{fulllineitems}

\index{LIGHTGREEN\_EX (src.colorama.ansi.AnsiBack attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack.LIGHTGREEN_EX}\pysigline{\bfcode{LIGHTGREEN\_EX}\strong{ = 102}}
\end{fulllineitems}

\index{LIGHTMAGENTA\_EX (src.colorama.ansi.AnsiBack attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack.LIGHTMAGENTA_EX}\pysigline{\bfcode{LIGHTMAGENTA\_EX}\strong{ = 105}}
\end{fulllineitems}

\index{LIGHTRED\_EX (src.colorama.ansi.AnsiBack attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack.LIGHTRED_EX}\pysigline{\bfcode{LIGHTRED\_EX}\strong{ = 101}}
\end{fulllineitems}

\index{LIGHTWHITE\_EX (src.colorama.ansi.AnsiBack attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack.LIGHTWHITE_EX}\pysigline{\bfcode{LIGHTWHITE\_EX}\strong{ = 107}}
\end{fulllineitems}

\index{LIGHTYELLOW\_EX (src.colorama.ansi.AnsiBack attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack.LIGHTYELLOW_EX}\pysigline{\bfcode{LIGHTYELLOW\_EX}\strong{ = 103}}
\end{fulllineitems}

\index{MAGENTA (src.colorama.ansi.AnsiBack attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack.MAGENTA}\pysigline{\bfcode{MAGENTA}\strong{ = 45}}
\end{fulllineitems}

\index{RED (src.colorama.ansi.AnsiBack attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack.RED}\pysigline{\bfcode{RED}\strong{ = 41}}
\end{fulllineitems}

\index{RESET (src.colorama.ansi.AnsiBack attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack.RESET}\pysigline{\bfcode{RESET}\strong{ = 49}}
\end{fulllineitems}

\index{WHITE (src.colorama.ansi.AnsiBack attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack.WHITE}\pysigline{\bfcode{WHITE}\strong{ = 47}}
\end{fulllineitems}

\index{YELLOW (src.colorama.ansi.AnsiBack attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiBack.YELLOW}\pysigline{\bfcode{YELLOW}\strong{ = 43}}
\end{fulllineitems}


\end{fulllineitems}

\index{AnsiCodes (class in src.colorama.ansi)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiCodes}\pysigline{\strong{class }\code{src.colorama.ansi.}\bfcode{AnsiCodes}}
Bases: \code{object}

\end{fulllineitems}

\index{AnsiCursor (class in src.colorama.ansi)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiCursor}\pysigline{\strong{class }\code{src.colorama.ansi.}\bfcode{AnsiCursor}}
Bases: \code{object}
\index{BACK() (src.colorama.ansi.AnsiCursor method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiCursor.BACK}\pysiglinewithargsret{\bfcode{BACK}}{\emph{n=1}}{}
\end{fulllineitems}

\index{DOWN() (src.colorama.ansi.AnsiCursor method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiCursor.DOWN}\pysiglinewithargsret{\bfcode{DOWN}}{\emph{n=1}}{}
\end{fulllineitems}

\index{FORWARD() (src.colorama.ansi.AnsiCursor method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiCursor.FORWARD}\pysiglinewithargsret{\bfcode{FORWARD}}{\emph{n=1}}{}
\end{fulllineitems}

\index{POS() (src.colorama.ansi.AnsiCursor method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiCursor.POS}\pysiglinewithargsret{\bfcode{POS}}{\emph{x=1}, \emph{y=1}}{}
\end{fulllineitems}

\index{UP() (src.colorama.ansi.AnsiCursor method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiCursor.UP}\pysiglinewithargsret{\bfcode{UP}}{\emph{n=1}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{AnsiFore (class in src.colorama.ansi)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore}\pysigline{\strong{class }\code{src.colorama.ansi.}\bfcode{AnsiFore}}
Bases: {\hyperref[commands/apidoc/src.colorama:src.colorama.ansi.AnsiCodes]{\code{src.colorama.ansi.AnsiCodes}}}
\index{BLACK (src.colorama.ansi.AnsiFore attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore.BLACK}\pysigline{\bfcode{BLACK}\strong{ = 30}}
\end{fulllineitems}

\index{BLUE (src.colorama.ansi.AnsiFore attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore.BLUE}\pysigline{\bfcode{BLUE}\strong{ = 34}}
\end{fulllineitems}

\index{CYAN (src.colorama.ansi.AnsiFore attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore.CYAN}\pysigline{\bfcode{CYAN}\strong{ = 36}}
\end{fulllineitems}

\index{GREEN (src.colorama.ansi.AnsiFore attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore.GREEN}\pysigline{\bfcode{GREEN}\strong{ = 32}}
\end{fulllineitems}

\index{LIGHTBLACK\_EX (src.colorama.ansi.AnsiFore attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore.LIGHTBLACK_EX}\pysigline{\bfcode{LIGHTBLACK\_EX}\strong{ = 90}}
\end{fulllineitems}

\index{LIGHTBLUE\_EX (src.colorama.ansi.AnsiFore attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore.LIGHTBLUE_EX}\pysigline{\bfcode{LIGHTBLUE\_EX}\strong{ = 94}}
\end{fulllineitems}

\index{LIGHTCYAN\_EX (src.colorama.ansi.AnsiFore attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore.LIGHTCYAN_EX}\pysigline{\bfcode{LIGHTCYAN\_EX}\strong{ = 96}}
\end{fulllineitems}

\index{LIGHTGREEN\_EX (src.colorama.ansi.AnsiFore attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore.LIGHTGREEN_EX}\pysigline{\bfcode{LIGHTGREEN\_EX}\strong{ = 92}}
\end{fulllineitems}

\index{LIGHTMAGENTA\_EX (src.colorama.ansi.AnsiFore attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore.LIGHTMAGENTA_EX}\pysigline{\bfcode{LIGHTMAGENTA\_EX}\strong{ = 95}}
\end{fulllineitems}

\index{LIGHTRED\_EX (src.colorama.ansi.AnsiFore attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore.LIGHTRED_EX}\pysigline{\bfcode{LIGHTRED\_EX}\strong{ = 91}}
\end{fulllineitems}

\index{LIGHTWHITE\_EX (src.colorama.ansi.AnsiFore attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore.LIGHTWHITE_EX}\pysigline{\bfcode{LIGHTWHITE\_EX}\strong{ = 97}}
\end{fulllineitems}

\index{LIGHTYELLOW\_EX (src.colorama.ansi.AnsiFore attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore.LIGHTYELLOW_EX}\pysigline{\bfcode{LIGHTYELLOW\_EX}\strong{ = 93}}
\end{fulllineitems}

\index{MAGENTA (src.colorama.ansi.AnsiFore attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore.MAGENTA}\pysigline{\bfcode{MAGENTA}\strong{ = 35}}
\end{fulllineitems}

\index{RED (src.colorama.ansi.AnsiFore attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore.RED}\pysigline{\bfcode{RED}\strong{ = 31}}
\end{fulllineitems}

\index{RESET (src.colorama.ansi.AnsiFore attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore.RESET}\pysigline{\bfcode{RESET}\strong{ = 39}}
\end{fulllineitems}

\index{WHITE (src.colorama.ansi.AnsiFore attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore.WHITE}\pysigline{\bfcode{WHITE}\strong{ = 37}}
\end{fulllineitems}

\index{YELLOW (src.colorama.ansi.AnsiFore attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiFore.YELLOW}\pysigline{\bfcode{YELLOW}\strong{ = 33}}
\end{fulllineitems}


\end{fulllineitems}

\index{AnsiStyle (class in src.colorama.ansi)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiStyle}\pysigline{\strong{class }\code{src.colorama.ansi.}\bfcode{AnsiStyle}}
Bases: {\hyperref[commands/apidoc/src.colorama:src.colorama.ansi.AnsiCodes]{\code{src.colorama.ansi.AnsiCodes}}}
\index{BRIGHT (src.colorama.ansi.AnsiStyle attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiStyle.BRIGHT}\pysigline{\bfcode{BRIGHT}\strong{ = 1}}
\end{fulllineitems}

\index{DIM (src.colorama.ansi.AnsiStyle attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiStyle.DIM}\pysigline{\bfcode{DIM}\strong{ = 2}}
\end{fulllineitems}

\index{NORMAL (src.colorama.ansi.AnsiStyle attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiStyle.NORMAL}\pysigline{\bfcode{NORMAL}\strong{ = 22}}
\end{fulllineitems}

\index{RESET\_ALL (src.colorama.ansi.AnsiStyle attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.AnsiStyle.RESET_ALL}\pysigline{\bfcode{RESET\_ALL}\strong{ = 0}}
\end{fulllineitems}


\end{fulllineitems}

\index{clear\_line() (in module src.colorama.ansi)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.clear_line}\pysiglinewithargsret{\code{src.colorama.ansi.}\bfcode{clear\_line}}{\emph{mode=2}}{}
\end{fulllineitems}

\index{clear\_screen() (in module src.colorama.ansi)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.clear_screen}\pysiglinewithargsret{\code{src.colorama.ansi.}\bfcode{clear\_screen}}{\emph{mode=2}}{}
\end{fulllineitems}

\index{code\_to\_chars() (in module src.colorama.ansi)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.code_to_chars}\pysiglinewithargsret{\code{src.colorama.ansi.}\bfcode{code\_to\_chars}}{\emph{code}}{}
\end{fulllineitems}

\index{set\_title() (in module src.colorama.ansi)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansi.set_title}\pysiglinewithargsret{\code{src.colorama.ansi.}\bfcode{set\_title}}{\emph{title}}{}
\end{fulllineitems}



\subparagraph{\texttt{ansitowin32} Module}
\label{commands/apidoc/src.colorama:ansitowin32-module}\label{commands/apidoc/src.colorama:module-src.colorama.ansitowin32}\index{src.colorama.ansitowin32 (module)}\index{AnsiToWin32 (class in src.colorama.ansitowin32)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansitowin32.AnsiToWin32}\pysiglinewithargsret{\strong{class }\code{src.colorama.ansitowin32.}\bfcode{AnsiToWin32}}{\emph{wrapped}, \emph{convert=None}, \emph{strip=None}, \emph{autoreset=False}}{}
Bases: \code{object}

Implements a `write()' method which, on Windows, will strip ANSI character
sequences from the text, and if outputting to a tty, will convert them into
win32 function calls.
\index{ANSI\_CSI\_RE (src.colorama.ansitowin32.AnsiToWin32 attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansitowin32.AnsiToWin32.ANSI_CSI_RE}\pysigline{\bfcode{ANSI\_CSI\_RE}\strong{ = \textless{}\_sre.SRE\_Pattern object at 0x3ff4610\textgreater{}}}
\end{fulllineitems}

\index{ANSI\_OSC\_RE (src.colorama.ansitowin32.AnsiToWin32 attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansitowin32.AnsiToWin32.ANSI_OSC_RE}\pysigline{\bfcode{ANSI\_OSC\_RE}\strong{ = \textless{}\_sre.SRE\_Pattern object at 0x42d2cf0\textgreater{}}}
\end{fulllineitems}

\index{call\_win32() (src.colorama.ansitowin32.AnsiToWin32 method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansitowin32.AnsiToWin32.call_win32}\pysiglinewithargsret{\bfcode{call\_win32}}{\emph{command}, \emph{params}}{}
\end{fulllineitems}

\index{convert\_ansi() (src.colorama.ansitowin32.AnsiToWin32 method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansitowin32.AnsiToWin32.convert_ansi}\pysiglinewithargsret{\bfcode{convert\_ansi}}{\emph{paramstring}, \emph{command}}{}
\end{fulllineitems}

\index{convert\_osc() (src.colorama.ansitowin32.AnsiToWin32 method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansitowin32.AnsiToWin32.convert_osc}\pysiglinewithargsret{\bfcode{convert\_osc}}{\emph{text}}{}
\end{fulllineitems}

\index{extract\_params() (src.colorama.ansitowin32.AnsiToWin32 method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansitowin32.AnsiToWin32.extract_params}\pysiglinewithargsret{\bfcode{extract\_params}}{\emph{command}, \emph{paramstring}}{}
\end{fulllineitems}

\index{get\_win32\_calls() (src.colorama.ansitowin32.AnsiToWin32 method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansitowin32.AnsiToWin32.get_win32_calls}\pysiglinewithargsret{\bfcode{get\_win32\_calls}}{}{}
\end{fulllineitems}

\index{reset\_all() (src.colorama.ansitowin32.AnsiToWin32 method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansitowin32.AnsiToWin32.reset_all}\pysiglinewithargsret{\bfcode{reset\_all}}{}{}
\end{fulllineitems}

\index{should\_wrap() (src.colorama.ansitowin32.AnsiToWin32 method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansitowin32.AnsiToWin32.should_wrap}\pysiglinewithargsret{\bfcode{should\_wrap}}{}{}
True if this class is actually needed. If false, then the output
stream will not be affected, nor will win32 calls be issued, so
wrapping stdout is not actually required. This will generally be
False on non-Windows platforms, unless optional functionality like
autoreset has been requested using kwargs to init()

\end{fulllineitems}

\index{write() (src.colorama.ansitowin32.AnsiToWin32 method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansitowin32.AnsiToWin32.write}\pysiglinewithargsret{\bfcode{write}}{\emph{text}}{}
\end{fulllineitems}

\index{write\_and\_convert() (src.colorama.ansitowin32.AnsiToWin32 method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansitowin32.AnsiToWin32.write_and_convert}\pysiglinewithargsret{\bfcode{write\_and\_convert}}{\emph{text}}{}
Write the given text to our wrapped stream, stripping any ANSI
sequences from the text, and optionally converting them into win32
calls.

\end{fulllineitems}

\index{write\_plain\_text() (src.colorama.ansitowin32.AnsiToWin32 method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansitowin32.AnsiToWin32.write_plain_text}\pysiglinewithargsret{\bfcode{write\_plain\_text}}{\emph{text}, \emph{start}, \emph{end}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{StreamWrapper (class in src.colorama.ansitowin32)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansitowin32.StreamWrapper}\pysiglinewithargsret{\strong{class }\code{src.colorama.ansitowin32.}\bfcode{StreamWrapper}}{\emph{wrapped}, \emph{converter}}{}
Bases: \code{object}

Wraps a stream (such as stdout), acting as a transparent proxy for all
attribute access apart from method `write()', which is delegated to our
Converter instance.
\index{write() (src.colorama.ansitowin32.StreamWrapper method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansitowin32.StreamWrapper.write}\pysiglinewithargsret{\bfcode{write}}{\emph{text}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{is\_a\_tty() (in module src.colorama.ansitowin32)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansitowin32.is_a_tty}\pysiglinewithargsret{\code{src.colorama.ansitowin32.}\bfcode{is\_a\_tty}}{\emph{stream}}{}
\end{fulllineitems}

\index{is\_stream\_closed() (in module src.colorama.ansitowin32)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.ansitowin32.is_stream_closed}\pysiglinewithargsret{\code{src.colorama.ansitowin32.}\bfcode{is\_stream\_closed}}{\emph{stream}}{}
\end{fulllineitems}



\subparagraph{\texttt{initialise} Module}
\label{commands/apidoc/src.colorama:initialise-module}\label{commands/apidoc/src.colorama:module-src.colorama.initialise}\index{src.colorama.initialise (module)}\index{colorama\_text() (in module src.colorama.initialise)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.initialise.colorama_text}\pysiglinewithargsret{\code{src.colorama.initialise.}\bfcode{colorama\_text}}{\emph{*args}, \emph{**kwds}}{}
\end{fulllineitems}

\index{deinit() (in module src.colorama.initialise)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.initialise.deinit}\pysiglinewithargsret{\code{src.colorama.initialise.}\bfcode{deinit}}{}{}
\end{fulllineitems}

\index{init() (in module src.colorama.initialise)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.initialise.init}\pysiglinewithargsret{\code{src.colorama.initialise.}\bfcode{init}}{\emph{autoreset=False}, \emph{convert=None}, \emph{strip=None}, \emph{wrap=True}}{}
\end{fulllineitems}

\index{reinit() (in module src.colorama.initialise)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.initialise.reinit}\pysiglinewithargsret{\code{src.colorama.initialise.}\bfcode{reinit}}{}{}
\end{fulllineitems}

\index{reset\_all() (in module src.colorama.initialise)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.initialise.reset_all}\pysiglinewithargsret{\code{src.colorama.initialise.}\bfcode{reset\_all}}{}{}
\end{fulllineitems}

\index{wrap\_stream() (in module src.colorama.initialise)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.initialise.wrap_stream}\pysiglinewithargsret{\code{src.colorama.initialise.}\bfcode{wrap\_stream}}{\emph{stream}, \emph{convert}, \emph{strip}, \emph{autoreset}, \emph{wrap}}{}
\end{fulllineitems}



\subparagraph{\texttt{win32} Module}
\label{commands/apidoc/src.colorama:win32-module}\label{commands/apidoc/src.colorama:module-src.colorama.win32}\index{src.colorama.win32 (module)}\index{SetConsoleTextAttribute() (in module src.colorama.win32)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.win32.SetConsoleTextAttribute}\pysiglinewithargsret{\code{src.colorama.win32.}\bfcode{SetConsoleTextAttribute}}{\emph{*\_}}{}
\end{fulllineitems}

\index{winapi\_test() (in module src.colorama.win32)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.win32.winapi_test}\pysiglinewithargsret{\code{src.colorama.win32.}\bfcode{winapi\_test}}{\emph{*\_}}{}
\end{fulllineitems}



\subparagraph{\texttt{winterm} Module}
\label{commands/apidoc/src.colorama:winterm-module}\label{commands/apidoc/src.colorama:module-src.colorama.winterm}\index{src.colorama.winterm (module)}\index{WinColor (class in src.colorama.winterm)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinColor}\pysigline{\strong{class }\code{src.colorama.winterm.}\bfcode{WinColor}}
Bases: \code{object}
\index{BLACK (src.colorama.winterm.WinColor attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinColor.BLACK}\pysigline{\bfcode{BLACK}\strong{ = 0}}
\end{fulllineitems}

\index{BLUE (src.colorama.winterm.WinColor attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinColor.BLUE}\pysigline{\bfcode{BLUE}\strong{ = 1}}
\end{fulllineitems}

\index{CYAN (src.colorama.winterm.WinColor attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinColor.CYAN}\pysigline{\bfcode{CYAN}\strong{ = 3}}
\end{fulllineitems}

\index{GREEN (src.colorama.winterm.WinColor attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinColor.GREEN}\pysigline{\bfcode{GREEN}\strong{ = 2}}
\end{fulllineitems}

\index{GREY (src.colorama.winterm.WinColor attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinColor.GREY}\pysigline{\bfcode{GREY}\strong{ = 7}}
\end{fulllineitems}

\index{MAGENTA (src.colorama.winterm.WinColor attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinColor.MAGENTA}\pysigline{\bfcode{MAGENTA}\strong{ = 5}}
\end{fulllineitems}

\index{RED (src.colorama.winterm.WinColor attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinColor.RED}\pysigline{\bfcode{RED}\strong{ = 4}}
\end{fulllineitems}

\index{YELLOW (src.colorama.winterm.WinColor attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinColor.YELLOW}\pysigline{\bfcode{YELLOW}\strong{ = 6}}
\end{fulllineitems}


\end{fulllineitems}

\index{WinStyle (class in src.colorama.winterm)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinStyle}\pysigline{\strong{class }\code{src.colorama.winterm.}\bfcode{WinStyle}}
Bases: \code{object}
\index{BRIGHT (src.colorama.winterm.WinStyle attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinStyle.BRIGHT}\pysigline{\bfcode{BRIGHT}\strong{ = 8}}
\end{fulllineitems}

\index{BRIGHT\_BACKGROUND (src.colorama.winterm.WinStyle attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinStyle.BRIGHT_BACKGROUND}\pysigline{\bfcode{BRIGHT\_BACKGROUND}\strong{ = 128}}
\end{fulllineitems}

\index{NORMAL (src.colorama.winterm.WinStyle attribute)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinStyle.NORMAL}\pysigline{\bfcode{NORMAL}\strong{ = 0}}
\end{fulllineitems}


\end{fulllineitems}

\index{WinTerm (class in src.colorama.winterm)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinTerm}\pysigline{\strong{class }\code{src.colorama.winterm.}\bfcode{WinTerm}}
Bases: \code{object}
\index{back() (src.colorama.winterm.WinTerm method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinTerm.back}\pysiglinewithargsret{\bfcode{back}}{\emph{back=None}, \emph{light=False}, \emph{on\_stderr=False}}{}
\end{fulllineitems}

\index{cursor\_adjust() (src.colorama.winterm.WinTerm method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinTerm.cursor_adjust}\pysiglinewithargsret{\bfcode{cursor\_adjust}}{\emph{x}, \emph{y}, \emph{on\_stderr=False}}{}
\end{fulllineitems}

\index{erase\_line() (src.colorama.winterm.WinTerm method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinTerm.erase_line}\pysiglinewithargsret{\bfcode{erase\_line}}{\emph{mode=0}, \emph{on\_stderr=False}}{}
\end{fulllineitems}

\index{erase\_screen() (src.colorama.winterm.WinTerm method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinTerm.erase_screen}\pysiglinewithargsret{\bfcode{erase\_screen}}{\emph{mode=0}, \emph{on\_stderr=False}}{}
\end{fulllineitems}

\index{fore() (src.colorama.winterm.WinTerm method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinTerm.fore}\pysiglinewithargsret{\bfcode{fore}}{\emph{fore=None}, \emph{light=False}, \emph{on\_stderr=False}}{}
\end{fulllineitems}

\index{get\_attrs() (src.colorama.winterm.WinTerm method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinTerm.get_attrs}\pysiglinewithargsret{\bfcode{get\_attrs}}{}{}
\end{fulllineitems}

\index{get\_position() (src.colorama.winterm.WinTerm method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinTerm.get_position}\pysiglinewithargsret{\bfcode{get\_position}}{\emph{handle}}{}
\end{fulllineitems}

\index{reset\_all() (src.colorama.winterm.WinTerm method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinTerm.reset_all}\pysiglinewithargsret{\bfcode{reset\_all}}{\emph{on\_stderr=None}}{}
\end{fulllineitems}

\index{set\_attrs() (src.colorama.winterm.WinTerm method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinTerm.set_attrs}\pysiglinewithargsret{\bfcode{set\_attrs}}{\emph{value}}{}
\end{fulllineitems}

\index{set\_console() (src.colorama.winterm.WinTerm method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinTerm.set_console}\pysiglinewithargsret{\bfcode{set\_console}}{\emph{attrs=None}, \emph{on\_stderr=False}}{}
\end{fulllineitems}

\index{set\_cursor\_position() (src.colorama.winterm.WinTerm method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinTerm.set_cursor_position}\pysiglinewithargsret{\bfcode{set\_cursor\_position}}{\emph{position=None}, \emph{on\_stderr=False}}{}
\end{fulllineitems}

\index{set\_title() (src.colorama.winterm.WinTerm method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinTerm.set_title}\pysiglinewithargsret{\bfcode{set\_title}}{\emph{title}}{}
\end{fulllineitems}

\index{style() (src.colorama.winterm.WinTerm method)}

\begin{fulllineitems}
\phantomsection\label{commands/apidoc/src.colorama:src.colorama.winterm.WinTerm.style}\pysiglinewithargsret{\bfcode{style}}{\emph{style=None}, \emph{on\_stderr=False}}{}
\end{fulllineitems}


\end{fulllineitems}



\chapter{Release Notes}
\label{index:release-notes}

\section{Release notes}
\label{release_notes/release_notes_5.0.0:release-notes}\label{release_notes/release_notes_5.0.0::doc}
In construction.


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{s}
\item {\texttt{src.\_\_init\_\_}}, \pageref{commands/apidoc/src:module-src.__init__}
\item {\texttt{src.architecture}}, \pageref{commands/apidoc/src:module-src.architecture}
\item {\texttt{src.colorama}}, \pageref{commands/apidoc/src.colorama:module-src.colorama}
\item {\texttt{src.colorama.ansi}}, \pageref{commands/apidoc/src.colorama:module-src.colorama.ansi}
\item {\texttt{src.colorama.ansitowin32}}, \pageref{commands/apidoc/src.colorama:module-src.colorama.ansitowin32}
\item {\texttt{src.colorama.initialise}}, \pageref{commands/apidoc/src.colorama:module-src.colorama.initialise}
\item {\texttt{src.colorama.win32}}, \pageref{commands/apidoc/src.colorama:module-src.colorama.win32}
\item {\texttt{src.colorama.winterm}}, \pageref{commands/apidoc/src.colorama:module-src.colorama.winterm}
\item {\texttt{src.compilation}}, \pageref{commands/apidoc/src:module-src.compilation}
\item {\texttt{src.debug}}, \pageref{commands/apidoc/src:module-src.debug}
\item {\texttt{src.ElementTree}}, \pageref{commands/apidoc/src:module-src.ElementTree}
\item {\texttt{src.environment}}, \pageref{commands/apidoc/src:module-src.environment}
\item {\texttt{src.fileEnviron}}, \pageref{commands/apidoc/src:module-src.fileEnviron}
\item {\texttt{src.fork}}, \pageref{commands/apidoc/src:module-src.fork}
\item {\texttt{src.logger}}, \pageref{commands/apidoc/src:module-src.logger}
\item {\texttt{src.options}}, \pageref{commands/apidoc/src:module-src.options}
\item {\texttt{src.printcolors}}, \pageref{commands/apidoc/src:module-src.printcolors}
\item {\texttt{src.product}}, \pageref{commands/apidoc/src:module-src.product}
\item {\texttt{src.pyconf}}, \pageref{commands/apidoc/src:module-src.pyconf}
\item {\texttt{src.system}}, \pageref{commands/apidoc/src:module-src.system}
\item {\texttt{src.template}}, \pageref{commands/apidoc/src:module-src.template}
\item {\texttt{src.test\_module}}, \pageref{commands/apidoc/src:module-src.test_module}
\item {\texttt{src.xmlManager}}, \pageref{commands/apidoc/src:module-src.xmlManager}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
